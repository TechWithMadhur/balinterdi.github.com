<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ember.js | Balint Erdi's blog about Ember.js]]></title>
  <link href="http://balinterdi.com/blog/categories/ember-js/atom.xml" rel="self"/>
  <link href="http://balinterdi.com/"/>
  <updated>2015-09-10T16:36:03+02:00</updated>
  <id>http://balinterdi.com/</id>
  <author>
    <name><![CDATA[I'm all about Ember.js recently]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Complex Component Design in Ember.js - Intro]]></title>
    <link href="http://balinterdi.com/2015/09/10/complex-component-design-in-ember-intro.html"/>
    <updated>2015-09-10T11:07:00+02:00</updated>
    <id>http://balinterdi.com/2015/09/10/complex-component-design-in-ember-intro</id>
    <content type="html"><![CDATA[<p>The title would probably better be "Somewhat Complex Component Design in Ember.js"
but any title including 'Somewhat' rules out pompousness. I therefore don't
claim that the series of blog posts I intend to start here will represent the
paramount of component design in Ember. There definitely are and definitely will
be more complex component structures and scenarios.</p>

<p>The component developed in the series is one that autocompletes as the user
starts to write the input and allows selecting from a fixed set of options.
Nothing extraordinary but complex enough so that the design/interaction
principles can be applied and explained while developing the component.</p>

<p>Important disclaimer: I am not an expert on component design (which, it seems
to me, is quite a complex topic). I got intrigued by it thanks to <a href="https://twitter.com/ryanflorence">Ryan Florence</a>
and his talks and learned most of the basics from him. My choice of component
probably also has to do something with Ryan. He developed the ic-autocomplete
component from which I took several ideas, sometimes simply copying the
implementation.</p>

<h3>Rationale</h3>

<p>So you probably ask: why reinvent the wheel? Why develop something that is
already done and not something new?</p>

<p>First of all, I (and science says most of us) learn best by doing. I wanted to
use an example where I already have a sample implementation but also understand
why the original implementation did things as it did and see whether I can make
the component simpler or more robust. I wanted to face the problems, to feel
the pain of doing things a certain way, and find solutions for typical,
recurring problems.</p>

<p>It's also important to remember that when Ryan developed their autocomplete
component, there were no block parameters, no closure actions and no direct
attribute bindings. One still had to resort to observers in several cases.
Two-way bindings were still in, and the de-facto way of communication between
pieces of a component structure.</p>

<p>Ember has come a long way since then and its components converged toward those
of React in its reactive, "rerender everything" approach. Potentially some of
the ideas explained in the series can be applied to React and other libraries,
too, and thus might prove useful to more people.</p>

<h3>So many words, so little code</h3>

<p>To have something (almost) tangible in this first intro post, too, let me show
you how one would interact with the finished(?) component. If you have read my
<a href="/2014/06/26/ember-gotcha-controllers-are-singletons.html">earlier</a> <a href="/2014/03/05/sorting-arrays-in-ember-dot-js-by-various-criteria.html">posts</a> or <a href="http://rockandrollwithemberjs.com">my book</a>, it will come as no surprise that I use it here to
select a great musician from a defined set of them:</p>

<p><img src="/images/posts/complex-component-design-ember/ember-autocomplete-demo.gif" alt="Selecting an
artist" /></p>

<p>This short intro and the demo have hopefully whetted your appetite and you'll
join me for the next part of the series:</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to do a select (dropdown) in Ember 2.0?]]></title>
    <link href="http://balinterdi.com/2015/08/29/how-to-do-a-select-dropdown-in-ember-20.html"/>
    <updated>2015-08-29T17:43:00+02:00</updated>
    <id>http://balinterdi.com/2015/08/29/how-to-do-a-select-dropdown-in-ember-20</id>
    <content type="html"><![CDATA[<iframe
  width="178" height="24" style="border:0px"
  src="https://mixonic.github.io/ember-community-versions/2015/08/29/how-to-do-a-select-dropdown-in-ember-2-0.html">
</iframe>


<p>When the select view was about to be removed from Ember, a lot of people
-myself included- wondered how it was going to be replaced. My bet was on a
'select component', after all, views should be transformed into components, right?</p>

<p>Then I saw <a href="https://gist.github.com/ef4/8367f996eb7b57d1f7a5">this gist</a> from Edward Faulkner:</p>

<p><div>
  <pre><code class='html'>&lt;select onchange={{action (mut vehicle) value=&quot;target.value&quot;}}&gt;
  {{#each vehicles as |vehicleChoice|}}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;option value={{vehicleChoice}} selected={{eq vehicle vehicleChoice}}&amp;gt;{{vehicleChoice}}&amp;lt;/option&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  {{/each}}
&lt;/select&gt;</code></pre>
</div>
</p>

<p>I did not understand half of it, so I dug down to see how the pieces come
together. In this short post, I want to explain what I have found out.</p>

<h3>Solve a simpler problem</h3>

<p>A great mathematician, George Polya, wrote a book in 1945 called <a href="http://smile.amazon.com/How-Solve-It-Mathematical-Princeton/dp/069111966X/ref=smi_www_rco2_go_smi_g2147660602?_encoding=UTF8&amp;*Version*=1&amp;*entries*=0&amp;ie=UTF8">"How to Solve It"</a>,
in which he puts down a framework for solving mathematical problems. One
(probably more) of his recommendations can be applied to software development,
too: Solve a simpler problem.</p>

<p>Heeding this advice, we'll first tackle a more mundane problem and in the
second round, we'll solve the original riddle.</p>

<p>Let's assume Edward had written the following:</p>

<p><div>
  <pre><code class='html'>&lt;select onchange={{action &quot;selectVehicle&quot; value=&quot;target.value&quot;}}&gt;
  {{#each vehicles as |vehicleChoice|}}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;option value={{vehicleChoice}} selected={{eq vehicle vehicleChoice}}&amp;gt;{{vehicleChoice}}&amp;lt;/option&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  {{/each}}
&lt;/select&gt;</code></pre>
</div>
</p>

<p>```js
import Ember from 'ember';</p>

<p>export default Ember.Controller.extend({
  vehicle: null,
  vehicles: Ember.String.w('Tesla Chrysler Toyota'),
  actions: {</p>

<pre><code>selectVehicle(vehicle) {
  this.set('vehicle', vehicle);
}
</code></pre>

<p>  }
});
```</p>

<p>This is easier (as in: more familiar) but there are still a few things that
might need explanation. First, before 1.13.3, event listeners on browser
events could not trigger Ember actions like that:</p>

<p><div>
  <pre><code class='html'>&lt;select onchange={{action &quot;selectVehicle&quot; value=&quot;target.value&quot;}}&gt;</code></pre>
</div>
</p>

<p>What this does, is that when the selected value of the dropdown changes, it
fires the onchange listener we added on the <code>&lt;select&gt;</code> which results in calling
our action handler, <code>selectVehicle</code>. The handler just updates the <code>vehicle</code>
property of the controller. This will mark as selected the dropdown option the
user picked due to the <code>selected={{eq vehicle vehicleChoice}}</code> term.</p>

<p>(<code>eq</code> comes from a great little Ember addon called <a href="https://github.com/jmurphyau/ember-truth-helpers">ember-truth-helpers</a>. It
returns true if the two parameters are equal).</p>

<p>Since there is no two-way binding set up between the selected option of the
dropdown and the controller property (<code>vehicle</code>), this needs to be done using a
DOM event listener (<code>onchange</code>) and updating in the action handler. That's
exactly what happens in the <code>selectVehicle</code> action handler.</p>

<p>So far so good, let's move on.</p>

<h3>Solve the original one</h3>

<p>Wait a minute. How did <code>selectVehicle</code> receive the selected vehicle choice (e.g
Toyota) when the <code>{{action}}</code> helper did not specify any parameters?</p>

<p>When the browser calls an event listener, it passes it an event object which
would become the first parameter of <code>selectVehicle</code>. However, <code>selectVehicle</code>
does not receive the event but the actual value of the selected option, how does
that come about? The missing link is a lesser-known option of the <code>action</code>
helper, <code>value</code>. The property passed to it is read off of the first parameter of
the handler and then replaces it. In our example, <code>target.value</code> is looked up on
the event object, which is exactly the value of the select option that triggered
the <code>onchange</code> event.</p>

<p>Ok, only one thing left.</p>

<p>The original example had this line:</p>

<p><div>
  <pre><code class='html'>&lt;select onchange={{action (mut vehicle) value=&quot;target.value&quot;}}&gt;</code></pre>
</div>
</p>

<p>instead of the more familiar:</p>

<p><div>
  <pre><code class='html'>&lt;select onchange={{action &quot;selectVehicle&quot; value=&quot;target.value&quot;}}&gt;</code></pre>
</div>
</p>

<p>What mut does here is that it allows updating the passed property, so when the
action is called, <code>vehicle</code> is set to the passed value, the value of the
selected option. That is it, we solved the riddle.</p>

<p>The same implementation pattern can be used to update the properties related to
checkboxes, input fields and radio buttons. This new way of doing things takes a
while to get used to, but we'll see more and more of it with one-way bindings
becoming best practice.</p>

<p>(By the way, my PR to add a section about <a href="https://github.com/emberjs/guides/pull/670">the actions helper's <code>value</code> option</a> to
the guides was merged yesterday, so hopefully more people will know about it.)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rock and Roll With Ember.js v1.13.7 Is Out]]></title>
    <link href="http://balinterdi.com/2015/08/07/rock-and-roll-with-ember-dot-js-v1-dot-13-dot-7-is-out.html"/>
    <updated>2015-08-07T11:38:00+02:00</updated>
    <id>http://balinterdi.com/2015/08/07/rock-and-roll-with-ember-dot-js-v1-dot-13-dot-7-is-out</id>
    <content type="html"><![CDATA[<p>I am happy to announce another update to the Rock and Roll with Ember.js book,
in line with the latest Ember CLI, 1.13.7. Book customers have already received
the updated version, here is how it got better:</p>

<ul>
<li><strong>Update to Ember CLI 1.13.7</strong></li>
<li><strong>Upgrade to Ember version 1.13.6</strong></li>
<li>Explain better the difference between sync and async test helpers and how
these latter work in Ember</li>
<li>Make the stubs for creating bands and songs not take an id, to be similar to
how the actual API works</li>
<li>Update section about Ember Data being in beta</li>
<li>Show what the custom <code>submit</code> async helper does when it first appears</li>
<li>Remove unit tests for components as <code>ember generate component-test</code> now
generates integration-style tests</li>
<li>Extract the <code>wait</code> helper used across two examples (for showing loading
routes/templates)</li>
<li>Update jsbin in the Templates chapter to use the latest Ember version</li>
<li>Fix importing the capitalizeHelper in the code snippet in the book</li>
<li><p>Last but not least, the pdf version of the book now has page numbers and a
nice, expandable table of contents so you can jump to any chapter or section
from anywhere:</p>

<p><img src="/images/posts/rarwe-1-13-7/preview-toc.png" alt="Collapsable TOC and page numbers" /></p>

<p>I know, it seems extremely simple to have them from the start but the way the
pdf was generated did not allow for this so we had to find another way. I
again worked with <a href="http://murtra.net/">Almudena Garcia</a> on these design
changes and I whole-heartedly recommend her if you have some front-end (HTML &amp;
CSS) tasks to get done.</p></li>
</ul>


<p>There are a couple of other, smaller changes and you can see the whole list in
<a href="https://github.com/balinterdi/rarwe-issues/issues?q=is%3Aissue+milestone%3A1.13.7+is%3Aclosed">the issues repo</a>. Or you can buy the book <a href="http://rockandrollwithemberjs.com">here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rock and Roll with Ember.js v1.13.3 is out]]></title>
    <link href="http://balinterdi.com/2015/07/17/rock-and-roll-with-ember-dot-js-v1-dot-13-3-is-out.html"/>
    <updated>2015-07-17T10:47:00+02:00</updated>
    <id>http://balinterdi.com/2015/07/17/rock-and-roll-with-ember-dot-js-v1-dot-13-3-is-out</id>
    <content type="html"><![CDATA[<p>It's Friday and if it's (every 2nd-6th) Friday, it's Rock and Roll release day!</p>

<p>Book version 1.13.3 is rolling out as we speak (ok, we don't speak and you
probably read this later, but you get the point) which contains the following
changes:</p>

<ul>
<li><strong>Upgrade to Ember version 1.13.3 (the book is in lockstep, too!)</strong></li>
<li><strong>Update to Ember CLI 1.13.1</strong></li>
<li><p><strong>Extended the Components chapter with closure actions.</strong></p>

<p><a href="http://emberjs.com/blog/2015/06/12/ember-1-13-0-released.html#toc_closure-actions">Closure actions</a> are an awesome new way to fire/handle actions introduced
in 1.13 and so it has to be in the book!</p></li>
<li><p><strong>Extended the Testing chapter with component integration tests.</strong></p>

<p>Integration tests make component tests super simple to set up and so much more
descriptive than unit tests. Our beloved star-rating component is now tested
by the shiny new integration tests.</p></li>
<li><p><strong>Get rid of <code>needs</code> in the controller.</strong></p>

<p>There was one instance where I used this to get a nice placeholder text. As a
preparation for Ember 2.0 where <code>needs</code> is going the way of the dodo, I
removed that nasty <code>needs</code>.</p></li>
<li><p><strong>Specify the band-songs relationship as sync.</strong></p>

<p>Starting from 2.0, Ember Data relationships are assumed to be asynchronous
unless otherwise specified. In the Rock &amp; Roll application, we sideload the
songs with the bands, so adding a <code>{ async: false }</code> option to the
relationship was in order.</p></li>
<li><strong>A few CSS fixes, one of them thanks to <a href="https://twitter.com/lonekorean">lonekorean</a></strong></li>
</ul>


<p>The whole change list is observable <a href="https://github.com/balinterdi/rarwe-issues/issues?q=milestone%3A1.13.3+is%3Aclosed">here</a>.</p>

<p>Hoist the sails, Ember 2.0 (and with it, Rock and Roll with Ember 2.0) is on the horizon!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rock and Roll with Ember.js v1.13 is out]]></title>
    <link href="http://balinterdi.com/2015/07/03/rock-and-roll-with-ember-dot-js-v1-dot-13-is-out.html"/>
    <updated>2015-07-03T15:25:00+02:00</updated>
    <id>http://balinterdi.com/2015/07/03/rock-and-roll-with-ember-dot-js-v1-dot-13-is-out</id>
    <content type="html"><![CDATA[<p>Today marks the sixth release of my book, <a href="http://rockandrollwithemberjs.com">Rock and Roll with Ember.js</a>, and
brings it in sync with Ember 1.13. The book follows along the development from
scratch of an Ember application, and chapter by chapter and explains concepts in
the process.</p>

<p>As I have promised, the book is kept up-to-date with the latest stable Ember
version. That implies both using idiomatic Ember and not using deprecated
syntaxes or APIs.</p>

<p>Now that the versioning of Ember Data is in lockstep with that of Ember, I
considered it important to update to the latest Ember Data, too, and will
strive to do so in future releases, too.</p>

<p>Here are the major things I updated for the 1.13 release:</p>

<ul>
<li>Use <code>this.route</code> instead of <code>this.resource</code> in the router map as the latter is now deprecated.</li>
<li>Use <code>Ember.computed</code> and <code>Ember.on</code> instead of the Function prototype
extensions, <code>property</code> and <code>on</code> as extending the Function prototype is
consired a poor practice.</li>
<li>Update the "Getting ready for Ember 2.0" chapter as most things are clear now
for the 2.0 release. As I give particular examples for each deprecation, this
chapter can also serve as an update guide for 1.x Ember applications.</li>
<li>Use the new Ember Data find methods, namely <code>store.findAll</code> and
<code>store.findRecord</code>. Before, both fetching a collection and a single record
used <code>store.find</code>.</li>
</ul>


<p>As usual, there are also smaller improvements and fixes and you can find the
whole list in the errata/issues repository for the book, assigned to <a href="https://github.com/balinterdi/rarwe-issues/issues?q=milestone%3A1.13+is%3Aclosed">the release milestone.</a></p>
]]></content>
  </entry>
  
</feed>
