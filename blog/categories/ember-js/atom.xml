<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ember.js | Balint Erdi's blog about Ember.js]]></title>
  <link href="http://balinterdi.com/blog/categories/ember-js/atom.xml" rel="self"/>
  <link href="http://balinterdi.com/"/>
  <updated>2015-10-28T09:16:40+01:00</updated>
  <id>http://balinterdi.com/</id>
  <author>
    <name><![CDATA[I'm all about Ember.js recently]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The tale of two bindings]]></title>
    <link href="http://balinterdi.com/2015/10/22/the-tale-of-two-bindings.html"/>
    <updated>2015-10-22T16:41:00+02:00</updated>
    <id>http://balinterdi.com/2015/10/22/the-tale-of-two-bindings</id>
    <content type="html"><![CDATA[<iframe
  width="178" height="24" style="border:0px"
  src="https://mixonic.github.io/ember-community-versions/2015/10/22/the-tale-of-two-bindings.html">
</iframe>


<p>Two weeks ago I had a presentation called "Complex component design" at the
Global Ember Meetup.</p>

<p>When I had given the title and abstract of this presentation, I had wanted to
speak about how to implement more involved, nested components in Ember 2 (but
actually, more like 1.13+), which is a fascinating and complex (pun intended)
topic. I had something like a highly reusable autocomplete input component in
mind something that <a href="http://balinterdi.com/2015/09/10/complex-component-design-in-ember-intro.html">I had decided to explore further</a>.</p>

<p>When I sat down to think about it, I had realized there is a related and equally
fascinating topic, that of communication between components that live on the
same page. As everything is <a href="https://github.com/emberjs/rfcs/pull/38">soon becoming a component</a> in Ember, the two are
very similar. A difference is that communicating components in an app do not
need such a high degree of flexibility as a reusable component (like an Ember
addon). In any case, it does not hurt, since making them flexible facilitates
their reuse.</p>

<p>In this post, I'll show an example of simple component communication and focus
on how moving from two-way bindings to one-way bindings changes that. Spending
some time on playing around with this, I was very pleasantly surprised in what
this shift enables.</p>

<h3>The example</h3>

<p>If you know me a bit, you'd expect the "app" to be Rock &amp; Roll themed and
you'd be right. I reduced the app <a href="http://rockandrollwithemberjs.com">in the book</a> to a very simple interface
where you can pick a band and then edit it on a form:</p>

<p><img src="/images/posts/tale-of-two-bindings/sketch.png" alt="Edit band on a form" /></p>

<p>In the remainder of the post, we'll see different implementations to achieve the
validation and saving of the band. There will be 3 scenarios: the traditional
one, using two-way bindings, the Glimmer version, using one-way bindings, DOM
events and Data Down, Actions up (DDAU) and finally 1WAY Deluxe&#8482;: adding a few
features on top of the second scenario that one-way bindings make easy (or
possible at all).</p>

<h3>Take 1: Traditional, two-way bound</h3>

<p>Ignoring the list of bands on the left, the template belonging to the band
route, where the band can be edited, contains the band-form (on the right of the
screenshot), and some minimal markup. We pass in the band object, the <code>on-save</code> and the
<code>on-star-click</code> closure actions to the band form:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;div class=&quot;panel panel-default band-panel&quot;&gt;
  &lt;div class=&quot;panel-body&quot;&gt;
    {{band-form band=model
                errors=errors
                on-save=(action &quot;saveBand&quot;)
                on-star-click=(action &quot;updateRating&quot;)}}
  &lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;</code></pre>
</div>
</p>

<p>The controller has these actions, sets up the errors object and contains the
validation logic. The <code>hasErrors</code> property will be true if the band's name is
empty:</p>

<p><div>
  <pre><code class='javascript'>import Ember from &#39;ember&#39;;&lt;/p&gt;

&lt;p&gt;export default Ember.Controller.extend({
  hasValidName: Ember.computed.notEmpty(&#39;model.name&#39;),
  hasErrors: Ember.computed.not(&#39;hasValidName&#39;),&lt;/p&gt;

&lt;p&gt;  setupErrors: Ember.on(&#39;init&#39;, function() {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.set(&#39;errors&#39;, Ember.Object.create());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  }),&lt;/p&gt;

&lt;p&gt;  validate() {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.set(&#39;errors.name&#39;, this.get(&#39;hasValidName&#39;) ? null : &quot;Name is required.&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  },&lt;/p&gt;

&lt;p&gt;  actions: {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;updateRating(params) {
  const { item: band, rating } = params;
  band.set(&#39;rating&#39;, rating);
},

saveBand() {
  this.validate();
  if (this.get(&#39;hasErrors&#39;)) {
    return;
  }

  const band = this.get(&#39;model&#39;);
  return band.save().then(() =&amp;gt; {
    console.log(&quot;Band is saved&quot;);
  });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  }
});</code></pre>
</div>
</p>

<p>Upon validation, the errors are set but this is only needed to be able to
show the error in the template. <code>this.get('hasErrors')</code> is already true if the
band's name is an empty string.</p>

<p>The missing piece is the <code>band-form</code> template:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;div class={{if errors.name &quot;form-group has-error&quot; &quot;form-group&quot;}}&gt;
  &lt;label for=&quot;band-name&quot;&gt;Name&lt;/label&gt;
  {{input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;band-name&quot; value=band.name}}
&lt;/div&gt;


&lt;div class=&quot;form-group&quot;&gt;
  &lt;label for=&quot;band-year&quot;&gt;Formed in&lt;/label&gt;
  {{input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;band-year&quot; value=band.year}}
&lt;/div&gt;


&lt;div class=&quot;form-group&quot;&gt;
  &lt;label for=&quot;band-rating&quot;&gt;Rating&lt;/label&gt;
  {{star-rating id=&quot;band-rating&quot; item=band rating=band.rating on-click=on-star-click}}
&lt;/div&gt;


&lt;p&gt;&lt;button type=&quot;submit&quot; class=&quot;btn btn-primary pull-right&quot; {{action &quot;saveBand&quot;}}&gt;Submit&lt;/button&gt;</code></pre>
</div>
</p>

<p>It uses the <code>input</code> helper which established two-way bindings between the value
of the input and the property that was passed to it. When the user modifies the
input, <code>band.name</code> changes in sync. Since band in the component is the model of
the controller, the band name in the list changes as the name is edited:</p>

<p><img src="/images/posts/tale-of-two-bindings/two-way-bindings-in-action.gif" alt="Two-way bindings in action" /></p>

<p>In this scenario, communication between the top-level component (controller, if
you will) and the band form is quite blunt. As data is two-way bound, there is
no simple, "in-framework" way of not changing the name in the list when the name
on the form is modified. There is shared state and the components do not act via
messages: they pull two ends of the same string.</p>

<p>(In cases where you had to prevent that in the pre-Glimmer era, you had to resort
to using a separate property, like <code>band.newName</code>, or using <a href="https://github.com/yapplabs/ember-buffered-proxy">BufferedProxy</a>.)</p>

<p>So let's take a step forwards and see how this can be improved.</p>

<h3>Take 2: One-way bound with DDAU</h3>

<p>We'll first replace the two-way binding with a one-way one and manually
synchronize the upstream direction using DDAU. It will not seem like a big gain
but it will enable us to go further and attain 1WAY Deluxe&#8482;.</p>

<p>The top-level template only needs a slight change. We no longer pass in an
<code>on-star-click</code> action but instead an <code>on-update</code> one. This will serve for the
upstream synchronization, setting what changed in the component on the band
object (the model) of the controller.</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;div class=&quot;panel panel-default band-panel&quot;&gt;
  &lt;div class=&quot;panel-body&quot;&gt;
    {{band-form band=model
                errors=errors
                on-save=(action &quot;saveBand&quot;)
                on-update=(action &quot;updateBandProperty&quot;)}}
  &lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;</code></pre>
</div>
</p>

<p>In accordance, the only thing that has changed in the controller is that
the <code>updateStarRating</code> action has been replaced by <code>updateBandProperty</code>. This is
the manual syncing:</p>

<p><div>
  <pre><code class='javascript'>export default Ember.Controller.extend({
  (...)
  actions: {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;updateBandProperty(property, value) {
  this.get(&#39;model&#39;).set(property, value);
},

(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  }
});</code></pre>
</div>
</p>

<p>In the template, the two-way bound <code>input</code> helpers are out, substituted by
regular input tags. We attach event listeners to them which will trigger the
synchronization proces (I wrote <a href="http://balinterdi.com/2015/08/29/how-to-do-a-select-dropdown-in-ember-20.html">a post</a> about how that works a few months ago):</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;div class={{if errors.name &quot;form-group has-error&quot; &quot;form-group&quot;}}&gt;
  &lt;label for=&quot;band-name&quot;&gt;Name&lt;/label&gt;
  &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;band-name&quot; value={{band.name}}
    oninput={{action &quot;nameDidChange&quot; value=&quot;target.value&quot;}} /&gt;
&lt;/div&gt;


&lt;div class=&quot;form-group&quot;&gt;
  &lt;label for=&quot;band-year&quot;&gt;Formed in&lt;/label&gt;
  &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;band-year&quot; value={{band.year}}
    oninput={{action &quot;yearDidChange&quot; value=&quot;target.value&quot;}} /&gt;
&lt;/div&gt;


&lt;div class=&quot;form-group&quot;&gt;
  &lt;label for=&quot;band-rating&quot;&gt;Rating&lt;/label&gt;
  {{star-rating id=&quot;band-rating&quot; item=band rating=band.rating on-click=(action &quot;ratingDidChange&quot;)}}
&lt;/div&gt;


&lt;p&gt;&lt;button type=&quot;submit&quot; class=&quot;btn btn-primary pull-right&quot; {{action &quot;saveBand&quot;}}&gt;Submit&lt;/button&gt;</code></pre>
</div>
</p>

<p><code>nameDidChange</code>, <code>yearDidChange</code> and <code>ratingDidChange</code> all end up calling the
passed in closure action, <code>on-update</code>, with the name of the property that has
changed and its new value. This calls <code>updateBandProperty</code> in the controller we
already saw:</p>

<p><div>
  <pre><code class='html'>import Ember from &#39;ember&#39;;&lt;/p&gt;

&lt;p&gt;export default Ember.Component.extend({
  tagName: &#39;form&#39;,
  band: null,
  errors: null,
  &quot;on-update&quot;: null,
  &quot;on-save&quot;: null,&lt;/p&gt;

&lt;p&gt;  actions: {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;saveBand() {
  this.attrs[&#39;on-save&#39;]();
},

nameDidChange(value) {
  this.attrs[&#39;on-update&#39;](&#39;name&#39;, value);
},
yearDidChange(value) {
  this.attrs[&#39;on-update&#39;](&#39;year&#39;, value);
},
ratingDidChange(params) {
  const { rating } = params;
  this.attrs[&#39;on-update&#39;](&#39;rating&#39;, rating);
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  }
});</code></pre>
</div>
</p>

<p>From the outside, the app works just as before. The band name changes in the
list as we edit it in the text field:</p>

<p><img src="/images/posts/tale-of-two-bindings/one-way-bindings-in-action.gif" alt="One-way bindings in action" /></p>

<p>However, we know that under the hood our code took control of propagating data
changes. We have undone the string that kept the two sides (two components)
tied strongly together. In the third and final iteration, we'll leverage that to
move validation where it belongs and add a micro-feature.</p>

<h3>Take 3: 1WAY Deluxe&#8482;</h3>

<p>Now, for the cool part. Now that we're free to change band-related properties on
the component without affecting the properties of the band object (the model of
the controller), we no longer have a shared state.</p>

<p>The first thing we'll do is to move the validation into the <code>band-form component</code>.
<code>band-form</code> will be also less chatty. It will only send property updates when
the form is submitted. That means we don't need to pass in the <code>errors</code> object
or an <code>on-update</code> action:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;div class=&quot;panel panel-default band-panel&quot;&gt;
  &lt;div class=&quot;panel-body&quot;&gt;
    {{band-form band=model on-save=(action &quot;saveBand&quot;)}}
  &lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;</code></pre>
</div>
</p>

<p>That implies that the controller can be really slimmed down to the <code>saveBand</code>
action:</p>

<p><div>
  <pre><code class='html'>import Ember from &#39;ember&#39;;&lt;/p&gt;

&lt;p&gt;export default Ember.Controller.extend({
  actions: {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;saveBand(properties) {
  const band = this.get(&#39;model&#39;);
  band.setProperties(properties);

  return band.save().then(() =&amp;gt; {
    console.log(&quot;Band is saved&quot;);
  });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  }
});</code></pre>
</div>
</p>

<p>Note how the input field values in the <code>band-form</code> template are now bound to
properties on the component as opposed to that of the passed in <code>band</code> object:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;div class={{if errors.name &quot;form-group has-error&quot; &quot;form-group&quot;}}&gt;
  &lt;label for=&quot;band-name&quot;&gt;Name&lt;/label&gt;
  &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;band-name&quot; value={{name}}
    oninput={{action &quot;nameDidChange&quot; value=&quot;target.value&quot;}} /&gt;
&lt;/div&gt;


&lt;div class=&quot;form-group&quot;&gt;
  &lt;label for=&quot;band-year&quot;&gt;Formed in&lt;/label&gt;
  &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;band-year&quot; value={{year}}
    oninput={{action &quot;yearDidChange&quot; value=&quot;target.value&quot;}} /&gt;
&lt;/div&gt;


&lt;div class=&quot;form-group&quot;&gt;
  &lt;label for=&quot;band-rating&quot;&gt;Rating&lt;/label&gt;
  {{star-rating id=&quot;band-rating&quot; item=band rating=rating on-click=(action &quot;ratingDidChange&quot;)}}
&lt;/div&gt;


&lt;div class=&quot;form-group button-panel&quot;&gt;
  &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary pull-right&quot; {{action &quot;saveBand&quot;}}&gt;Submit&lt;/button&gt;
  &lt;button type=&quot;button&quot; class=&quot;btn btn-danger pull-right&quot; {{action &quot;reset&quot;}}&gt;Reset&lt;/button&gt;
&lt;/div&gt;


&lt;p&gt;</code></pre>
</div>
</p>

<p>Little else has changed but a second button, Reset, already gives you a taste of
things to come. Let's see the component definition:</p>

<p><div>
  <pre><code class='javascript'>import Ember from &#39;ember&#39;;&lt;/p&gt;

&lt;p&gt;export default Ember.Component.extend({
  tagName: &#39;form&#39;,
  band: null,
  &quot;on-save&quot;: null,&lt;/p&gt;

&lt;p&gt;  name:    null,
  year:    null,
  rating:  null,
  errors:  null,&lt;/p&gt;

&lt;p&gt;  // Validation code comes here, copied verbatim from the controller&lt;/p&gt;

&lt;p&gt;  resetOnInit: Ember.on(&#39;init&#39;, function() {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.resetFromBand();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  }),&lt;/p&gt;

&lt;p&gt;  resetFromBand() {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&#39;name&#39;, &#39;year&#39;, &#39;rating&#39;].forEach((field) =&amp;gt; {
  const valueInBand = this.get(&#39;band&#39;).get(field);
  this.set(field, valueInBand);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  },&lt;/p&gt;

&lt;p&gt;  actions: {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;saveBand() {
  this.validate();
  if (this.get(&#39;hasErrors&#39;)) {
    return;
  }

  return this.attrs[&#39;on-save&#39;](this.getProperties([&#39;name&#39;, &#39;year&#39;, &#39;rating&#39;]));
},

nameDidChange(value) {
  this.set(&#39;name&#39;, value);
},
yearDidChange(value) {
  this.set(&#39;year&#39;, value);
},
ratingDidChange(params) {
  const { rating } = params;
  this.set(&#39;rating&#39;, value);
},
reset() {
  this.resetFromBand();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  }
});</code></pre>
</div>
</p>

<p>I cut out the code responsible for validation since that has just been brought
over from the controller.</p>

<p>The interesting stuff happens in <code>resetFromBand</code> which is both called when the
component comes to life and when the Reset button is clicked. It copies the
<code>name</code>, <code>year</code> and <code>rating</code> properties of the band onto those of the component,
effectively resetting them to their original value. That's the only reason we
still need to pass in the band object into the component.</p>

<p>Also notice how the <code>name</code> and the <code>rating</code> are not updated on the band object
as we interact with the form:</p>

<p><img src="/images/posts/tale-of-two-bindings/one-way-deluxe-in-action.gif" alt="1WAY Deluxe in action" /></p>

<p>Having the data validated by the form acts as a guard. The save action is only
triggered if the data was found to be valid. It is only then that the form's
data will overwrite that of the band object. Data flows both ways but in a very
controlled way.</p>

<p>To take this further, thanks to closure actions, we could even display an error in the <code>band-form</code>
component if the save operation fails on the controller:</p>

<p><div>
  <pre><code class='javascript'>export default Ember.Component.extend({
  (...)
  actions: {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;saveBand() {
  this.validate();
  if (this.get(&#39;hasErrors&#39;)) {
    return;
  }
  const properties = this.getProperties([&#39;name&#39;, &#39;year&#39;, &#39;rating&#39;]);
  return this.attrs[&#39;on-save&#39;](properties)
    .catch((error) =&amp;gt; {
      this.set(&#39;errors.base&#39;, error.get(&#39;message&#39;));
    });
},

(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  }
});</code></pre>
</div>
</p>

<p><strong>UPDATE</strong></p>

<h3>Take 4: 1WAY Deluxe&#8482; without input cursor wackiness</h3>

<p>The above 1WAY Deluxe&#8482; has a bug that <a href="https://twitter.com/rwjblue">Robert Jackson</a> pointed out and that
I did not realize while building the demo app. The cursor in the text field
always jumps back at the end of the text after each change:</p>

<p><img src="/images/posts/tale-of-two-bindings/1way-deluxe-input-wackiness.gif" alt="1WAY Deluxe input wackiness" /></p>

<p>During the Glimmer rewrite he spend a lot of time tracking down that bug, the
result of which is the <a href="https://github.com/dockyard/ember-one-way-input"><code>ember-one-way-input</code> Ember addon</a>.</p>

<p>So that's what we should use instead of regular input tags. We first install the
addon with <code>ember install ember-one-way-input</code>. That gives us a <code>one-way-input</code>
component that takes an <code>update</code> action which will be triggered at each change
of the input's value (more precisely, on both <code>change</code> and <code>input</code> events).</p>

<p>Let's replace the input tags in the component's template:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;div class={{if errors.name &quot;form-group has-error&quot; &quot;form-group&quot;}}&gt;
  &lt;label for=&quot;band-name&quot;&gt;Name&lt;/label&gt;
  {{one-way-input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;band-name&quot; value=name
    update=(action &quot;nameDidChange&quot;)}}
&lt;/div&gt;


&lt;div class=&quot;form-group&quot;&gt;
  &lt;label for=&quot;band-year&quot;&gt;Formed in&lt;/label&gt;
  {{one-way-input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;band-year&quot; value=year
    update=(action &quot;yearDidChange&quot;)}}
&lt;/div&gt;


&lt;div class=&quot;form-group&quot;&gt;
  &lt;label for=&quot;band-rating&quot;&gt;Rating&lt;/label&gt;
  {{star-rating id=&quot;band-rating&quot; item=band rating=rating on-click=(action &quot;ratingDidChange&quot;)}}
&lt;/div&gt;


&lt;div class=&quot;form-group button-panel&quot;&gt;
  &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary pull-right&quot; {{action &quot;saveBand&quot;}}&gt;Submit&lt;/button&gt;
  &lt;button type=&quot;button&quot; class=&quot;btn btn-danger pull-right&quot; {{action &quot;reset&quot;}}&gt;Reset&lt;/button&gt;
&lt;/div&gt;


&lt;p&gt;</code></pre>
</div>
</p>

<p>Nothing else needs to change for the cursor position weirdness to go away:</p>

<p><img src="/images/posts/tale-of-two-bindings/1way-deluxe-with-one-way-input.gif" alt="1WAY Deluxe input without cursor wackiness" /></p>

<p>Thank you to <a href="https://twitter.com/rwjblue">Robert Jackson</a> and <a href="https://twitter.com/toranb">Toran Billups</a> for spotting this and pointing me
to the solution.</p>

<h3>Conclusion</h3>

<p>I'm really excited and curious about how many things this makes possible. As I
said in my presentation, we're (but surely: I am) only figuring out both the
possibilities "managed" one-way bindings open up and the best way to work with
them. So if you have thoughts or insights, please do share them in the comments.</p>

<p>NOTE: I published <a href="https://github.com/balinterdi/tale-of-two-bindings">the demo app of this post on Github.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rock and Roll with Ember 2 just went live]]></title>
    <link href="http://balinterdi.com/2015/10/01/rock-and-roll-with-ember-2-just-went-live.html"/>
    <updated>2015-10-01T09:48:00+02:00</updated>
    <id>http://balinterdi.com/2015/10/01/rock-and-roll-with-ember-2-just-went-live</id>
    <content type="html"><![CDATA[<p>The 2nd edition of my critically acclaimed book, <a href="http://rockandrollwithemberjs.com">Rock and Roll with
Ember.js</a>, has just been published. The number 2 does not only denote the 2nd
edition but also the fact that it runs on Ember (and Ember Data) 2.0 and that it
will follow the 2.x development path of the framework.</p>

<p>The 2nd edition adds 4 new chapters: Animations, Making an Ember
addon, Writing modern JavaScript (ES2015) and Deployment. Here is the complete
set list:</p>

<ol>
<li>Introduction to Ember.js</li>
<li>Ember CLI</li>
<li>Templates and data bindings</li>
<li>Routing</li>
<li>Nested routes</li>
<li>Actions</li>
<li>Components</li>
<li>Controllers</li>
<li>Advanced routing</li>
<li>Talking to a backend - with Ember Data</li>
<li>Testing</li>
<li>Sorting and searching with query params</li>
<li>Loading and error routes</li>
<li>Helpers</li>
<li>Animations</li>
<li>Making an Ember addon</li>
<li>ES2015 - Writing modern JavaScript</li>
<li>Deployment</li>
</ol>


<p>As many readers have said, keeping the book up-to-date with the latest stable
Ember release also makes it a great reference book on current Ember idioms and
features.</p>

<p>Oh, and did I mention I am running a 20% discount on all packages until Monday,
10/05, 23:59 PST?  There are also a few other goodies in the bag, so I encourage
you to <a href="http://rockandrollwithemberjs.com">check out the book now</a> before prices revert to their normal level.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Select in Ember with multiple selection]]></title>
    <link href="http://balinterdi.com/2015/09/25/select-in-ember-with-multiple-selection.html"/>
    <updated>2015-09-25T14:24:00+02:00</updated>
    <id>http://balinterdi.com/2015/09/25/select-in-ember-with-multiple-selection</id>
    <content type="html"><![CDATA[<iframe
  width="178" height="24" style="border:0px"
  src="https://mixonic.github.io/ember-community-versions/2015/09/25/select-in-ember-with-multiple-selection.html">
</iframe>


<p>A few weeks ago I wrote a blog post about <a href="http://balinterdi.com/2015/08/29/how-to-do-a-select-dropdown-in-ember-20.html">how to do a select in Ember 2</a>,
that seemed to be popular. I also received good comments about advanced versions
of the same problem, namely how the solution would have to change to deal with
the case if the items to select from are objects and how to tackle multiple
selections. I thus decided to do a Part 2, showing a solution for these cases.
Comment are welcome, as always.</p>

<h3>Multiple selection with simple strings as items</h3>

<p>Let's tackle the easier problem first, being able to select more than one items,
but the items are simple string values. The values will serve both as the value
and the content of the options.</p>

<p>I added some extra Bootstrap markup and a list to see which items are selected:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;div class=&quot;container&quot;&gt;
  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-8&quot;&gt;
      &lt;h2&gt;Select some bands&lt;/h2&gt;
      &lt;select style=&quot;height:100px&quot; class=&quot;form-control&quot; multiple onchange={{action &quot;selectBand&quot;}}&gt;
        {{#each bands as |bandChoice|}}
        &lt;option value={{bandChoice}} selected={{include selectedBands bandChoice}}&gt;{{bandChoice}}&lt;/option&gt;
        {{/each}}
      &lt;/select&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-4&quot;&gt;
      {{#if selectedCount}}
        &lt;h2&gt;Selected bands ({{selectedCount}})&lt;/h2&gt;
      {{else}}
        &lt;h2&gt;Selected bands&lt;/h2&gt;
      {{/if}}
      &lt;ul class=&quot;list-group&quot;&gt;
        {{#each selectedBands as |band|}}
          &lt;li class=&quot;list-group-item&quot;&gt;{{band}}&lt;/li&gt;
        {{else}}
          &lt;li class=&quot;list-group-item&quot;&gt;No band selected.&lt;/li&gt;
        {{/each}}
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;</code></pre>
</div>
</p>

<p>I added the <code>multiple</code> attribute to the <code>select</code> tag to allow multiple
selections. Not much has changed from the earlier example. When the user
selects an option, whether in a way that clears the earlier selection (simple
click) or adds to it (ctrl/cmd + click), the <code>onchange</code> event is fired, and our
<code>selectBand</code> handler will handle it. We expect that handler to set
<code>selectedBands</code> so that the list of selected bands gets updated correctly. So
let's see the controller:</p>

<p><div>
  <pre><code class='html'>export default Ember.Controller.extend({
  bands: [&#39;Pearl Jam&#39;, &#39;Tool&#39;, &#39;Long Distance Calling&#39;, &#39;Led Zeppelin&#39;],&lt;/p&gt;

&lt;p&gt;  selectedBands: [],&lt;/p&gt;

&lt;p&gt;  selectedCount: Ember.computed.reads(&#39;selectedBands.length&#39;),&lt;/p&gt;

&lt;p&gt;  actions: {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;selectBand(event) {
  const selectedBands = Ember.$(event.target).val();
  this.set(&#39;selectedBands&#39;, selectedBands || []);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  }
});</code></pre>
</div>
</p>

<p>For multiple selections, jQuery, aliased as <code>Ember.$</code>, returns an array of the
selected options values as the select's value, so all we have to do is assign
this to the <code>selectedBands</code> property. In case nothing is selected, <code>val()</code>
returns <code>null</code>, so we guard against transferring this to <code>selectedBands</code> by
defaulting to an empty array.</p>

<p>There is one more thing you might have noticed, and that is the <code>include</code> helper
in the template. We want to mark the option as selected if its value is included
in the selectedBands:</p>

<p><div>
  <pre><code class='html'>&lt;select style=&quot;height:100px&quot; class=&quot;form-control&quot; multiple onchange={{action &quot;selectBand&quot;}}&gt;
  {{#each bands as |bandChoice|}}
  &lt;option value={{bandChoice}} selected={{include selectedBands bandChoice}}&gt;{{bandChoice}}&lt;/option&gt;
  {{/each}}
&lt;/select&gt;</code></pre>
</div>
</p>

<p>The <code>include</code> helper is not provided by Ember but it is rather easy to write
ourselves:</p>

<p><div>
  <pre><code class='html'>import Ember from &#39;ember&#39;;&lt;/p&gt;

&lt;p&gt;export function include(params) {
  const [items, value] = params;
  return items.indexOf(value) &gt; -1;
}&lt;/p&gt;

&lt;p&gt;export default Ember.Helper.helper(include);</code></pre>
</div>
</p>

<p>That is all there is to it:</p>

<p><img src="/images/posts/select-in-ember-with-multiple-selections/multiple-select-with-ember.gif" alt="Multiple selection" /></p>

<h3>Multiple selection with objects as items</h3>

<p>This is just a tad more difficult, as we cannot directly have objects as options
values. Let's assume that these objects have a property that identifies them
unambiguously (which is a fair assumption to make), usually referred to as <code>id</code>:</p>

<p><div>
  <pre><code class='html'>import Ember from &#39;ember&#39;;&lt;/p&gt;

&lt;p&gt;export default Ember.Controller.extend({
  bands: [&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ember.Object.create({ id: &quot;1&quot;, name: &#39;Pearl Jam&#39;, formedIn: 1990 }),
Ember.Object.create({ id: &quot;2&quot;, name: &#39;Tool&#39;, formedIn: 1991 }),
Ember.Object.create({ id: &quot;3&quot;, name: &#39;Long Distance Calling&#39;, formedIn: 2003 }),
Ember.Object.create({ id: &quot;4&quot;, name: &#39;Led Zeppelin&#39;, formedIn: 1970 })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  ],
  (...)
});</code></pre>
</div>
</p>

<p>We'll use the <code>id</code> as the option value and display the name:</p>

<p><div>
  <pre><code class='html'>(...)
&lt;select style=&quot;height:100px&quot; class=&quot;form-control&quot; multiple onchange={{action &quot;selectBand&quot;}}&gt;
  {{#each bands as |bandChoice|}}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;option value={{bandChoice.id}} selected={{include selectedBandIds bandChoice.id}}&amp;gt;{{bandChoice.name}}&amp;lt;/option&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  {{/each}}
&lt;/select&gt;
(...)</code></pre>
</div>
</p>

<p>On the controller, we collect the id of each selected band, and if we need to
display their names, we simply make the mapping between these two:</p>

<p><div>
  <pre><code class='html'>export default Ember.Controller.extend({
  (...)
  selectedBandIds: [],&lt;/p&gt;

&lt;p&gt;  selectedBands: Ember.computed(&#39;selectedBandIds.[]&#39;, function() {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return this.get(&#39;selectedBandIds&#39;).map((bandId) =&amp;gt; {
  return this.get(&#39;bands&#39;).findBy(&#39;id&#39;, bandId);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  }),
  (...)
});</code></pre>
</div>
</p>

<p><code>bands.findBy</code> is our makeshift store service, which allows us to find an object
in a collection by its id. If we used Ember Data, it would become
<code>store.findRecord('band', bandId)</code> or <code>store.peekRecord('band', bandId)</code>. The
only other difference from before is that we set <code>selectedBandIds</code> instead of
<code>selectedBands</code> in the action handler:</p>

<p><div>
  <pre><code class='html'>export default Ember.Controller.extend({
  (...)
  actions: {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;selectBand(event) {
  const selectedBandIds = Ember.$(event.target).val();
  this.set(&#39;selectedBandIds&#39;, selectedBandIds || []);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  }
});</code></pre>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rock and Roll With Ember 2 is coming soon!]]></title>
    <link href="http://balinterdi.com/2015/09/16/rock-and-roll-with-ember-2-is-coming-soon.html"/>
    <updated>2015-09-16T15:54:00+02:00</updated>
    <id>http://balinterdi.com/2015/09/16/rock-and-roll-with-ember-2-is-coming-soon</id>
    <content type="html"><![CDATA[<h3>tl;dr</h3>

<p>I will publish a second, extended edition of my book, Rock and Roll with Ember
in about two weeks, at the end of September. Here is what you need to know:</p>

<ul>
<li>I make the same promise as with the current edition: you buy it once, you get
all updates for free until 3.0 comes out</li>
<li>4 extra chapters are added about advanced Ember topics, bringing the number
of chapters to 18</li>
<li>There will be a short launch period where the book packages are offered at a
discount.</li>
</ul>


<p>To be in-the-loop about the launch and know about the launch discount, <a href="http://balinterdi.com/2015/09/16/rock-and-roll-with-ember-2-is-coming-soon.html#launch-date">sign up
below</a>,
at the end of the post. Read on for more details.</p>

<h3>The short past, present and future of Rock and Roll with Ember</h3>

<p>Almost exactly 7 months ago, I published my book, Rock and Roll with Ember.js,
that helps people learn the glorious framework. Ember has since went through
quite some changes and I kept the book up-to-date with roughly an update each
month.</p>

<p>Ember 2 was released about a month ago, on the 13rd of August. True to the
"stability without stagnation" philosophy, the 2.0 release did not contain any
new features but dropped a lot of deadweight, API methods and syntaxes that had
been deprecated somewhere along the 1.x process.</p>

<p>Thanks to the transparency of the road ahead through RFCs and discussions on
other forums, it can already be clearly seen that the 2.x series will bring a
great deal of new and fascinating features. Routable components, angle-bracket
components and contextual lookup in components are some of the bigger things
that we can expect on the road to 3.0. The expected simplifications (for
example, routable components replacing controllers) will come with major changes
in how one writes an idiomatic app in Ember 2.</p>

<p>I've been following along the 1.x series with fascination and a keen eye to
apply the changes to my book and the included application. I want to do the same
along the Ember 2.x line and thus I hereby announce the second edition of the
book, Rock and Roll with Ember 2!</p>

<h3>Free updates policy</h3>

<p>To clarify, with Rock and Roll with Ember 2,  I intend to follow the "book
development and release" process of the first edition of the book that I've now
named "Buy once, get all updates for free (until the next major version)". I
assert that if you buy any of my book packages, you get all subsequent updates
for free, until 3.0 lands (which is probably 12-18 months away. Geez, do I
really want to do that? :) ).</p>

<h3>New content</h3>

<p>Keeping the book's current content up-to-date is not all. The second edition
will contain 4 extra chapters on some advanced topics (Animations, Making an
Ember CLI addon, Deployment and ES2015 &amp; computed macros) bringing the total
chapter count to 18 (the Getting ready for Ember 2.0 is retired).</p>

<p>Further content changes are expected as Ember 2 evolves (see above for what can
already be known about these changes), so the content on launch day will by no
means be the final content of the book. It will constantly improve and be kept
in-sync with the latest stable 2.x version of Ember.</p>

<h3 id="launch-date">When does it launch?</h3>


<p>Very soon, probably in two weeks, mark the date (with a pencil, for the moment):
September 30, 2015.</p>

<p>Stand ready, Rock and Roll with Ember 2 is coming to a virtual bookstore near
you!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rock and Roll With Ember.js v1.13.9 Is Out]]></title>
    <link href="http://balinterdi.com/2015/09/11/rock-and-roll-with-ember-dot-js-v1-dot-13-dot-9-is-out.html"/>
    <updated>2015-09-11T11:42:00+02:00</updated>
    <id>http://balinterdi.com/2015/09/11/rock-and-roll-with-ember-dot-js-v1-dot-13-dot-9-is-out</id>
    <content type="html"><![CDATA[<p>I have just released another update to the Rock and Roll with Ember.js book,
keeping it in sync with Ember 1.13.9. On top of that (mostly on top of that,
since there weren't as many things to do for the Ember upgrade), I added some
content, removed some other ones, fixed a few wrong paths in code comments,
clarified a few code lines to help people build the app along, and the like. The
usual stuff, quoi.</p>

<p>Here are the bigger chunks:</p>

<ul>
<li>Extended the Testing chapter with a (controller) unit test. I removed the
component's unit test in an earlier update (integration tests are vastly
superior for components) but now realized unit testing was missing.</li>
<li>Switched to a dashless helper, <code>capitalize</code> instead of <code>capitalize-words</code>.
Ember 1.13.0 and up auto-register helpers with and without dashes, so there is
no need for the more verbose form.</li>
<li>Fixed a few places where the <code>updateRating</code> action was still in the route.
When I switched to a closure action, I had to move the action handler to the
controller but missed a couple of places in the subsequent chapters.</li>
<li>The epub version had two missing code snippets due to bad formatting (thanks
to <a href="https://github.com/morganick">@morganick</a>)</li>
</ul>


<p>There are a few other minor fixes, the whole list can be found in the <a href="https://github.com/balinterdi/rarwe-issues/issues?q=is%3Aissue+milestone%3A1.13.9+is%3Aclosed">Github issues repo</a></p>

<p>I want to thank <a href="http://andrew.davison-family.com">Andrew Davison</a> who did most
of the error reporting for this update. Thank you, Andrew!</p>

<p>Stay tuned for more goodies early next week, or sign up below so that you don't
miss any in the future.</p>
]]></content>
  </entry>
  
</feed>
