<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ember.js | Balint Erdi]]></title>
  <link href="http://balinterdi.com/blog/categories/ember-js/atom.xml" rel="self"/>
  <link href="http://balinterdi.com/"/>
  <updated>2014-06-06T15:19:45+02:00</updated>
  <id>http://balinterdi.com/</id>
  <author>
    <name><![CDATA[Balint Erdi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Replacing items in browser history in Ember.js]]></title>
    <link href="http://balinterdi.com/2014/06/04/replacing-items-in-browser-history-in-ember-dot-js.html"/>
    <updated>2014-06-04T07:49:00+02:00</updated>
    <id>http://balinterdi.com/2014/06/04/replacing-items-in-browser-history-in-ember-dot-js</id>
    <content type="html"><![CDATA[<p>One of the outstanding features of Ember.js is that all things related to URLs,
including going back and forth in browser history, just work. This is something
people got used to with "classical", server-side applications and that several
other client-side frameworks lack.</p>

<p>In this post, I am going to focus on a browser history feature, replacing
entries in it as users navigate between routes instead of adding to it.</p>

<h3>Navigating between routes in Ember</h3>

<p>If either the <code>link-to</code> template helper or the route's <code>transitionTo</code> method is
used to move between routes (and thus URLs), a new entry is going to be added to
the browser's history. That is fine most of the time but sometimes the desired
behavior might be replacing the current entry.</p>

<p>Taking the example from the guide, if one is paging through the comments made on
a photo where each one has its own route, we probably do not want these comment
URLs to clutter the history. Similarly, we don't want the user to land on these
URLs when she hits the Back button in the browser.</p>

<h3>Using the link-to helper</h3>

<p>All that needs to be done is adding the <code>replace=true</code> option to the <code>link-to</code> helper.</p>

<p>So if the link that takes you to the next comment is written like this:</p>

<p><div>
  <pre><code class='html'>{{link-to 'Next comment' 'photo.comment' nextComment}}</code></pre>
</div>
</p>

<p>It should now become:</p>

<p><div>
  <pre><code class='html'>{{link-to 'Next comment' 'photo.comment' nextComment replace=true}}</code></pre>
</div>
</p>

<h3>Transitioning from inside routes</h3>

<p>The canonical way to go from one route to another is <code>route.transitionTo</code>. If
flipping between comments of a photo was implemented as an action in the route,
the action handler would have the following line:</p>

<p><code>js
this.transitionTo('photo.comment', nextComment);
</code></p>

<p>To make that replace the current history entry, this becomes:</p>

<p><code>js
this.replaceWith('photo.comment', nextComment);
</code></p>

<p><code>replaceWith</code> takes the exact same parameters as <code>transitionTo</code>.</p>

<p>Curtain falls.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting the document title in Ember apps]]></title>
    <link href="http://balinterdi.com/2014/05/28/setting-the-document-title-in-ember-apps.html"/>
    <updated>2014-05-28T07:27:00+02:00</updated>
    <id>http://balinterdi.com/2014/05/28/setting-the-document-title-in-ember-apps</id>
    <content type="html"><![CDATA[<p>The document title serves as a quick and concise way to identify web pages. It
gets displayed in search results and bookmarks and allows the user to see at a
glance what content she has open in each tab.</p>

<p>Therefore it is important to have descriptive document titles in our web
applications, whether they get rendered on the backend or set in the client app.</p>

<p>In the following short post, I'll focus on showing how to do that with Ember.</p>

<h3>Setting the title property</h3>

<p>The way to set the document title from the browser is to just assign a
value to the <code>title</code> property of the document:</p>

<p><code>js
document.title = "1 mind-blowing way to set the title for your html document";
</code></p>

<p>Or, from jQuery:</p>

<p><code>js
$(document).attr('title',"1 mind-blowing way to set the title for your html document");
</code></p>

<h3>Having context-aware titles</h3>

<p>For our document titles to be really useful, it would be great to have some
kind of information from the page's content be reflected in them.</p>

<p>To use <a href="https://github.com/balinterdi/rock-and-rol://github.com/balinterdi/rock-and-roll">my favorite example app, Rock &amp; Roll</a>, I expect the page that
displays songs from a certain artist to have a segment that is common across all
pages in the app and another segment that uniquely identifies that page. For
songs of Led Zeppelin, this could be <code>Led Zeppelin songs - Rock &amp; Roll with
Ember.js</code>.</p>

<p>I choose to put the unique part first so it can be clearly seen in a tab even if
its width is limited.</p>

<h3>Finding the best place for setting the title</h3>

<p>When considering where to implement setting the title, we have to keep in mind
that the code has to run at each route transition so that the title for the new
page is correctly set. Also, the context of the page (in the above example, the
artist Led Zeppelin) already has to be known.</p>

<p>Considering these constraints, the title could be set either in the
<code>afterModel</code> or in the <code>setupController</code> hook. The controller instance is not
needed for setting the title so I'll go with the <code>afterModel</code> hook.</p>

<p>For the <code>artists</code> route, we content ourselves with setting a static title and we
can thus focus on the <code>artist.songs</code> route:</p>

<p>```js
App.ArtistSongsRoute = Ember.Route.extend({
  (...)
  afterModel: function(model) {</p>

<pre><code>var artistName = this.modelFor('artist').get('name');
$(document).attr('title', artistName + ' songs - Rock &amp; Roll');
</code></pre>

<p>  }
});
```</p>

<p>If we now navigate to the songs page for any artist, we can see the name of the
artist reflected in the tab title:</p>

<p><img src="/images/posts/set-document-title-in-ember/see-artist-in-tab-title.png" alt="Artist name in tab title" /></p>

<p><em>NOTE: Jonathan Evans has <a href="http://www.jrhe.co.uk/setting-the-document-title-in-ember-js-apps/">a great post</a> in which he uses the <code>didTransition</code>
action in routes to set the document title. I recommend you to read it.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Make your own computed property macro in Ember.js]]></title>
    <link href="http://balinterdi.com/2014/05/22/make-your-own-computed-property-macro-in-emberjs.html"/>
    <updated>2014-05-22T21:51:00+02:00</updated>
    <id>http://balinterdi.com/2014/05/22/make-your-own-computed-property-macro-in-emberjs</id>
    <content type="html"><![CDATA[<p>The most common way to define computed properties (CPs) in Ember.js apps is to
call the <code>property</code> function extension, passing in the "dependent keys",
the path patterns that should trigger the recomputation of the property's value.</p>

<p>The entry-level, classical example is <code>fullName</code>:</p>

<p>```js
App.Person = Ember.Object.extend({
  fullName: function() {</p>

<pre><code>return this.get('firstName') + ' ' + this.get('lastName');
</code></pre>

<p>  }.property('firstName', 'lastName')
});
```</p>

<p><code>person.get('fullName')</code> will change if and only if either firstName or lastName
has changed. Its value gets cached between changes.</p>

<p>This simple, yet extremely powerful, construct is a fundemental piece of what
makes Ember apps a joy to work with and capable of scaling out to build complex
apps.</p>

<p>Let's now define a slightly more difficult computed property:</p>

<p><code>js
latestPosts: function() {
  return this.get('sortedPosts').slice(0, 10);
}.property('sortedPosts.[]')
</code></p>

<p>Assuming that <code>this.get('sortedPosts')</code> contains the sorted posts <code>latestPosts</code>
is going to contain the first ten of these.</p>

<p>This is a very common pattern. We only want to show the 10 most recent posts,
the three top scorers on a Hall of Fame board or the 10 latest notifications of
a user. The above CP definition gets the job done. I see two ways it can be improved,
though.</p>

<p>First, it is prone to errors that are hard to debug. If you misspell
<code>sortedPosts</code> in the property(...) call, you can spend a considerable amount of
time trying to find out why your property does not update correctly.</p>

<p>Second, if it is used in several places of the application, it is a good idea
to extract the common pattern and reuse it to cut down on development time and
make the code more robust.</p>

<h3>Eliminating the duplication</h3>

<p>We need a repeatable way to create such computed properties that also eliminates
the risk of misspelling the property name:</p>

<p>``` js
function sliced(dependentKey, firstIndex, lastIndex) {
  return function() {</p>

<pre><code>return this.get(dependentKey).slice(firstIndex, lastIndex);
</code></pre>

<p>  }.property(dependentKey + ".[]");
}
```</p>

<p>This is exactly what we had before for <code>latestPosts</code>. Note the <code>.[]</code> in the
property path composition tucked after <code>dependentKey</code>. It guarantees that if any
of the elements in the array designated by <code>dependentKey</code> changes (elements are
added or removed), the property defined by <code>sliced</code> is going to be updated.</p>

<p>Then, whereever the need to slice up a certain array arises, we can use this
method to create it thusly:</p>

<p><code>js
App.DaysController = Ember.ArrayController.extend({
  workDays: sliced('model', 0, 5),
  weekend: sliced('model', 5)
})
</code></p>

<p>As usual, I put together an example to demonstrate how it works in practice:</p>

<p><a class="jsbin-embed" href="http://emberjs.jsbin.com/zemow/2/embed?js,output">Sliced property generator</a><script src="http://static.jsbin.com/js/embed.js"></script></p>

<h3>A couple of useful resources</h3>

<p>A handful of computed property macros are <a href="https://github.com/emberjs/ember.js/blob/master/packages/ember-metal/lib/computed.js">built into Ember</a>, while
the <a href="https://github.com/jamesarosen/ember-cpm">ember-cpm library</a> defines some more, so check these first if you
recurringly find yourself in need of a certain logic in computed properties.</p>

<p>If you still haven't found what you're looking for, this post hopefully sets you
on your way to define your own ones.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dependency injection in Ember.js - Going deeper]]></title>
    <link href="http://balinterdi.com/2014/05/16/dependency-injection-in-ember-dot-js-going-deeper.html"/>
    <updated>2014-05-16T11:55:00+02:00</updated>
    <id>http://balinterdi.com/2014/05/16/dependency-injection-in-ember-dot-js-going-deeper</id>
    <content type="html"><![CDATA[<p>In a previous post <a href="http://balinterdi.com/2014/05/01/dependency-injection-in-ember-dot-js.html">I introduced the basic elements of Dependency Injection in
Ember</a> and showed how to set up a dependency on the objects it is needed on.
I also mentioned the framework itself uses this same mechanism to establish its
dependencies.</p>

<p>In this post, I'll expand on this latter. I'll point at where these dependencies are
set up which gives me the possibility to introduce the options of the
basic parts, <code>register</code> and <code>inject</code>.</p>

<p>I'll also share a couple of tricks to prevent using the abominable
<code>this.__container__</code> and finish by showing how these pieces fit together in the
main method of the container, <code>container.lookup</code>.</p>

<h3>How does Ember do it?</h3>

<p>When an Ember app is created, the first thing it does is creating a container it
uses internally:</p>

<p>```js
var Application = Namespace.extend(DeferredMixin, {
  (...)
  init: function() {</p>

<pre><code>if (!this.$) { this.$ = jQuery; }
this.__container__ = this.buildContainer();
(...)
</code></pre>

<p>  },
  (...)
  buildContainer: function() {</p>

<pre><code>var container = this.__container__ = Application.buildContainer(this);

return container;
</code></pre>

<p>  },
}
```
(<a href="https://github.com/emberjs/ember.js/blob/v1.6.0-beta.4/packages_es6/ember-application/lib/system/application.js#L263">link to soure code</a>)</p>

<p>(Note: Here is where <code>App.__container__</code> gets set and thus you, as an application
developer has access to the underlying container. Notice the double underscores,
though. It tells you that you should not ever use that in "real" apps. There are
officially supported ways, public API methods to achieve whatever you strive to
achieve the forbidden way. It is sometimes enough <a href="https://twitter.com/mixonic/status/461595081607503872">to ask on Twitter.</a>)</p>

<p>Let's see how the container is built up (as usual, I cut out the parts that are
not relevant to the current subject):</p>

<p>```js
  buildContainer: function(namespace) {</p>

<pre><code>var container = new Container();

(...)
container.optionsForType('component', { singleton: false });
container.optionsForType('view', { singleton: false });
container.optionsForType('template', { instantiate: false });
container.optionsForType('helper', { instantiate: false });

container.register('application:main', namespace, { instantiate: false });

container.register('controller:basic', Controller, { instantiate: false });
container.register('controller:object', ObjectController, { instantiate: false });
container.register('controller:array', ArrayController, { instantiate: false });
container.register('route:basic', Route, { instantiate: false });

container.register('router:main',  Router);
container.injection('router:main', 'namespace', 'application:main');

(...)

container.injection('controller', 'target', 'router:main');
container.injection('controller', 'namespace', 'application:main');

container.injection('route', 'router', 'router:main');

(...)

return container;
</code></pre>

<p>  }
```
(<a href="https://github.com/emberjs/ember.js/blob/v1.6.0-beta.4/packages_es6/ember-application/lib/system/application.js#L826">link to source code</a>)</p>

<p>The faithful reader knows from the <a href="http://balinterdi.com/2014/05/01/dependency-injection-in-ember-dot-js.html">first part in the DI series</a> that the
above makes it so that e.g <code>this.namespace</code> points to the application in all controllers
or that <code>this.router</code> refers to the router in all routes.</p>

<p>Let's now turn out attention to the first definition block to learn new things.</p>

<h3>optionsForType</h3>

<p><code>optionsForType</code> is a comfortable way to define options that should be used when
looking up any instance of a particular type from the container.</p>

<p>It can be seen above that components and views are defined as non-singletons
which mean that any time a component or view is looked up on the container, a
new instance is created and returned.</p>

<p>I got me some code to prove it:</p>

<p>```js
App = Ember.Application.create();</p>

<p>var Artist = Ember.Object.extend();</p>

<p>Ember.Application.initializer({
  name: "setup",
  initialize: function(container, application) {</p>

<pre><code>container.optionsForType('model', { singleton: false });
container.register('model:artist', Artist);
</code></pre>

<p>  }
});</p>

<p>App.IndexRoute = Ember.Route.extend({
  model: function() {</p>

<pre><code>var artist1 = this.container.lookup('model:artist');
var artist2 = this.container.lookup('model:artist');
return [artist1, artist2];
</code></pre>

<p>  }
});</p>

<p>App.IndexController = Ember.ArrayController.extend({
  equal: function() {</p>

<pre><code>return this.get('firstObject') === this.get('lastObject');
</code></pre>

<p>  }.property('model.{firstObject, lastObject}')
});
```</p>

<p>If you then write a template for the index route that just displays the <code>equal</code>
property you'll see that its value is false, thus a new object is in fact
instantiated each time.</p>

<p>Here is <a href="http://emberjs.jsbin.com/zefuk/2/edit">a link to the jsbin</a> if you would like to see it.</p>

<p>If you replace <code>{ singleton: false }</code> with <code>{ singleton: true }</code> the equal
property is going to be true, the model object is going to be a true singleton.</p>

<h4>Singletons are the default</h4>

<p>As Ember core team meber <a href="http://balinterdi.com/2014/05/01/dependency-injection-in-ember-dot-js.html#comment-1386980817">Stefan Penner points out</a>, the <code>{ singleton: true
}</code> option is the default, so there is no need to explicitly state it.</p>

<p>As a consequence, <code>container.register('store:main', Store, { singleton: true })</code>
is exactly the same as <code>application.register('store', Store)</code>.</p>

<h4>Objects that come from the container can access it</h4>

<p>I learned this from <a href="http://madhatted.com/">Matthew Beale</a>, a prolific Ember contributor and presenter.
It's well worth your time <a href="https://www.youtube.com/watch?v=6FlWyOoo6hQ">to watch his presentation</a> on "Containers and
Dependency Injection" he gave at an Ember NYC meetup.</p>

<p>Amongst other useful stuff, he also reveals that all objects that come from the
container have access to it via a <code>container</code> property on them.</p>

<p>That allowed me to write <code>this.container.lookup</code> in the route above since routes
are created by the container, too.</p>

<p>This also does away with the need to use the private <code>__container__</code> in most
cases.</p>

<h3>To instantiate or not to instantiate</h3>

<p>Above, in the code for <code>buildContainer</code> you can see another option,
<code>instantiate</code>, which is false for templates and helpers. To save you from
scrolling all the way up, here are the relevant lines:</p>

<p><code>js
  container.optionsForType('template', { instantiate: false });
  container.optionsForType('helper', { instantiate: false });
</code></p>

<p>This option permits the registration of entities (yeah, stuff) that do not need
to be instantiated (or cannot be). Templates and helpers fit the bill since
they are functions and thus cannot be instantiated.</p>

<h3>container.lookup</h3>

<p>The lookup method in the container is a great summary for all the things discussed here.</p>

<p>``` js
function lookup(container, fullName, options) {
  options = options || {};</p>

<p>  if (container.cache.has(fullName) &amp;&amp; options.singleton !== false) { // 1</p>

<pre><code>return container.cache.get(fullName);
</code></pre>

<p>  }</p>

<p>  var value = instantiate(container, fullName); // 2</p>

<p>  if (value === undefined) { return; }</p>

<p>  if (isSingleton(container, fullName) &amp;&amp; options.singleton !== false) {</p>

<pre><code>container.cache.set(fullName, value); // 3
</code></pre>

<p>  }</p>

<p>  return value; // 4
}
```</p>

<p>First, if a singleton is needed and the object has already been looked up, we
just return the object saved in the cache. (see 1 above)</p>

<p>Next, we instantiate an object for the fullName (e.g 'controller:artists' or
'route:index'). The instantiate method takes care of just returning the value if
the <code>instantiate</code> option is set to false. (see 2 above)</p>

<p>If the instantiation was successful (the factory was found) and a singletion was
demanded, we set this value in the cache so that we can return it the next time
it is looked up. (see 3 above)</p>

<p>Finally, we return what was looked up. (see 4 above)</p>

<p><code>container.lookup</code> just calls the above function after verifying the fullName
has the right syntax, that is it has a type and a name part joined together by
a <code>:</code>.</p>

<p>And that's where everything comes together.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ember.run.bind]]></title>
    <link href="http://balinterdi.com/2014/05/09/ember-dot-run-dot-bind.html"/>
    <updated>2014-05-09T23:25:00+02:00</updated>
    <id>http://balinterdi.com/2014/05/09/ember-dot-run-dot-bind</id>
    <content type="html"><![CDATA[<p>Ember has several great features that are not widely known, like <a href="http://balinterdi.com/2014/05/01/dependency-injection-in-ember-dot-js.html">its Dependency Injection system</a> I wrote about last week.</p>

<p>It has also really handy API methods in hiding. One usually stumbles on them
while looking for something in the superbly commented source code.</p>

<p>I hereby introduce such a handy method and hope to make that into a recurring
thing. Who knows? Eventually this might also grow into a series.</p>

<p>If it does, I would have to find a catchy name for it. "Ember Chispas" came to
mind and rings nice but unfortunately <a href="https://www.youtube.com/user/edisonstew">Jeffrey Biles</a> already has a monopoly on it via his
"Ember Sparks" series. (<em>Chispa</em> is Spanish for spark.) We'll have to talk, Jeffrey :)</p>

<p>Anyway, let's see the first thingie.</p>

<h2>... and in the runloop bind them</h2>

<p>The run loop in Ember deserves its own blog post series, and I am probably not
the one who will write it. (<a href="http://emberjs.com/guides/understanding-ember/run-loop/">The official guide on the subject</a> is a good place
to start, <a href="http://alexmatchneer.com/blog/2013/01/12/everything-you-never-wanted-to-know-about-the-ember-run-loop/">Alex Matchneer's "Everything You Never Wanted to Know About the Ember Run Loop"</a> is more elaborate).</p>

<p>For the sake of this chispa, it suffices to state that any async callback from a 3rd
party javascript library needs to be wrapped into an Ember.run.</p>

<p>Blatantly stealing <a href="https://github.com/emberjs/ember.js/blob/24dcb0c566284a7aa926e701d33f40717264b9b1/packages_es6/ember-metal/lib/run_loop.js#L153">the example from the source code</a>, here is how this is done:</p>

<p>```javascript
var that = this;
jQuery(window).on('resize', function(){
  Ember.run(function(){</p>

<pre><code>that.handleResize();
</code></pre>

<p>  });
});
```</p>

<p>See that beautiful <code>var that=this;</code>? It can be got ridden of via <code>Ember.run.bind</code>:</p>

<p><code>javascript
jQuery(window).on('resize', Ember.run.bind(this, this.handleResize));
</code></p>

<p>Less code to write and all the mustaches are gone (not that there is anything
wrong with &#123;&#123;mustaches&#125;&#125;, of course).</p>
]]></content>
  </entry>
  
</feed>
