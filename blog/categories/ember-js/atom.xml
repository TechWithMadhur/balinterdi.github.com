<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ember.js | Balint Erdi]]></title>
  <link href="http://balinterdi.com/blog/categories/ember-js/atom.xml" rel="self"/>
  <link href="http://balinterdi.com/"/>
  <updated>2014-05-16T22:49:39+02:00</updated>
  <id>http://balinterdi.com/</id>
  <author>
    <name><![CDATA[Balint Erdi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dependency injection in Ember.js - Going deeper]]></title>
    <link href="http://balinterdi.com/2014/05/16/dependency-injection-in-ember-dot-js-going-deeper.html"/>
    <updated>2014-05-16T11:55:00+02:00</updated>
    <id>http://balinterdi.com/2014/05/16/dependency-injection-in-ember-dot-js-going-deeper</id>
    <content type="html"><![CDATA[<p>In a previous post <a href="http://balinterdi.com/2014/05/01/dependency-injection-in-ember-dot-js.html">I introduced the basic elements of Dependency Injection in
Ember</a> and showed how to set up a dependency on the objects it is needed on.
I also mentioned the framework itself uses this same mechanism to establish its
dependencies.</p>

<p>In this post, I'll expand on this latter. I'll point at where these dependencies are
set up which gives me the possibility to introduce the options of the
basic parts, <code>register</code> and <code>inject</code>.</p>

<p>I'll also share a couple of tricks to prevent using the abominable
<code>this.__container__</code> and finish by showing how these pieces fit together in the
main method of the container, <code>container.lookup</code>.</p>

<h3>How does Ember do it?</h3>

<p>When an Ember app is created, the first thing it does is creating a container it
uses internally:</p>

<p>```js
var Application = Namespace.extend(DeferredMixin, {
  (...)
  init: function() {</p>

<pre><code>if (!this.$) { this.$ = jQuery; }
this.__container__ = this.buildContainer();
(...)
</code></pre>

<p>  },
  (...)
  buildContainer: function() {</p>

<pre><code>var container = this.__container__ = Application.buildContainer(this);

return container;
</code></pre>

<p>  },
}
```
(<a href="https://github.com/emberjs/ember.js/blob/v1.6.0-beta.4/packages_es6/ember-application/lib/system/application.js#L263">link to soure code</a>)</p>

<p>(Note: Here is where <code>App.__container__</code> gets set and thus you, as an application
developer has access to the underlying container. Notice the double underscores,
though. It tells you that you should not ever use that in "real" apps. There are
officially supported ways, public API methods to achieve whatever you strive to
achieve the forbidden way. It is sometimes enough <a href="https://twitter.com/mixonic/status/461595081607503872">to ask on Twitter.</a>)</p>

<p>Let's see how the container is built up (as usual, I cut out the parts that are
not relevant to the current subject):</p>

<p>```js
  buildContainer: function(namespace) {</p>

<pre><code>var container = new Container();

(...)
container.optionsForType('component', { singleton: false });
container.optionsForType('view', { singleton: false });
container.optionsForType('template', { instantiate: false });
container.optionsForType('helper', { instantiate: false });

container.register('application:main', namespace, { instantiate: false });

container.register('controller:basic', Controller, { instantiate: false });
container.register('controller:object', ObjectController, { instantiate: false });
container.register('controller:array', ArrayController, { instantiate: false });
container.register('route:basic', Route, { instantiate: false });

container.register('router:main',  Router);
container.injection('router:main', 'namespace', 'application:main');

(...)

container.injection('controller', 'target', 'router:main');
container.injection('controller', 'namespace', 'application:main');

container.injection('route', 'router', 'router:main');

(...)

return container;
</code></pre>

<p>  }
```
(<a href="https://github.com/emberjs/ember.js/blob/v1.6.0-beta.4/packages_es6/ember-application/lib/system/application.js#L826">link to source code</a>)</p>

<p>The faithful reader knows from the <a href="http://balinterdi.com/2014/05/01/dependency-injection-in-ember-dot-js.html">first part in the DI series</a> that the
above makes it so that e.g <code>this.namespace</code> points to the application in all controllers
or that <code>this.router</code> refers to the router in all routes.</p>

<p>Let's now turn out attention to the first definition block to learn new things.</p>

<h3>optionsForType</h3>

<p><code>optionsForType</code> is a comfortable way to define options that should be used when
looking up any instance of a particular type from the container.</p>

<p>It can be seen above that components and views are defined as non-singletons
which mean that any time a component or view is looked up on the container, a
new instance is created and returned.</p>

<p>I got me some code to prove it:</p>

<p>```js
App = Ember.Application.create();</p>

<p>var Artist = Ember.Object.extend();</p>

<p>Ember.Application.initializer({
  name: "setup",
  initialize: function(container, application) {</p>

<pre><code>container.optionsForType('model', { singleton: false });
container.register('model:artist', Artist);
</code></pre>

<p>  }
});</p>

<p>App.IndexRoute = Ember.Route.extend({
  model: function() {</p>

<pre><code>var artist1 = this.container.lookup('model:artist');
var artist2 = this.container.lookup('model:artist');
return [artist1, artist2];
</code></pre>

<p>  }
});</p>

<p>App.IndexController = Ember.ArrayController.extend({
  equal: function() {</p>

<pre><code>return this.get('firstObject') === this.get('lastObject');
</code></pre>

<p>  }.property('model.{firstObject, lastObject}')
});
```</p>

<p>If you then write a template for the index route that just displays the <code>equal</code>
property you'll see that its value is false, thus a new object is in fact
instantiated each time.</p>

<p>Here is <a href="http://emberjs.jsbin.com/zefuk/2/edit">a link to the jsbin</a> if you would like to see it.</p>

<p>If you replace <code>{ singleton: false }</code> with <code>{ singleton: true }</code> the equal
property is going to be true, the model object is going to be a true singleton.</p>

<h4>Singletons are the default</h4>

<p>As Ember core team meber <a href="http://balinterdi.com/2014/05/01/dependency-injection-in-ember-dot-js.html#comment-1386980817">Stefan Penner points out</a>, the <code>{ singleton: true
}</code> option is the default, so there is no need to explicitly state it.</p>

<p>As a consequence, <code>container.register('store:main', Store, { singleton: true })</code>
is exactly the same as <code>application.register('store', Store)</code>.</p>

<h4>Objects that come from the container can access it</h4>

<p>I learned this from <a href="http://madhatted.com/">Matthew Beale</a>, a prolific Ember contributor and presenter.
It's well worth your time <a href="https://www.youtube.com/watch?v=6FlWyOoo6hQ">to watch his presentation</a> on "Containers and
Dependency Injection" he gave at an Ember NYC meetup.</p>

<p>Amongst other useful stuff, he also reveals that all objects that come from the
container have access to it via a <code>container</code> property on them.</p>

<p>That allowed me to write <code>this.container.lookup</code> in the route above since routes
are created by the container, too.</p>

<p>This also does away with the need to use the private <code>__container__</code> in most
cases.</p>

<h3>To instantiate or not to instantiate</h3>

<p>Above, in the code for <code>buildContainer</code> you can see another option,
<code>instantiate</code>, which is false for templates and helpers. To save you from
scrolling all the way up, here are the relevant lines:</p>

<p><code>js
  container.optionsForType('template', { instantiate: false });
  container.optionsForType('helper', { instantiate: false });
</code></p>

<p>This option permits the registration of entities (yeah, stuff) that do not need
to be instantiated (or cannot be). Templates and helpers fit the bill since
they are functions and thus cannot be instantiated.</p>

<h3>container.lookup</h3>

<p>The lookup method in the container is a great summary for all the things discussed here.</p>

<p>``` js
function lookup(container, fullName, options) {
  options = options || {};</p>

<p>  if (container.cache.has(fullName) &amp;&amp; options.singleton !== false) { // 1</p>

<pre><code>return container.cache.get(fullName);
</code></pre>

<p>  }</p>

<p>  var value = instantiate(container, fullName); // 2</p>

<p>  if (value === undefined) { return; }</p>

<p>  if (isSingleton(container, fullName) &amp;&amp; options.singleton !== false) {</p>

<pre><code>container.cache.set(fullName, value); // 3
</code></pre>

<p>  }</p>

<p>  return value; // 4
}
```</p>

<p>First, if a singleton is needed and the object has already been looked up, we
just return the object saved in the cache. (see 1 above)</p>

<p>Next, we instantiate an object for the fullName (e.g 'controller:artists' or
'route:index'). The instantiate method takes care of just returning the value if
the <code>instantiate</code> option is set to false. (see 2 above)</p>

<p>If the instantiation was successful (the factory was found) and a singletion was
demanded, we set this value in the cache so that we can return it the next time
it is looked up. (see 3 above)</p>

<p>Finally, we return what was looked up. (see 4 above)</p>

<p><code>container.lookup</code> just calls the above function after verifying the fullName
has the right syntax, that is it has a type and a name part joined together by
a <code>:</code>.</p>

<p>And that's where everything comes together.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ember.run.bind]]></title>
    <link href="http://balinterdi.com/2014/05/09/ember-dot-run-dot-bind.html"/>
    <updated>2014-05-09T23:25:00+02:00</updated>
    <id>http://balinterdi.com/2014/05/09/ember-dot-run-dot-bind</id>
    <content type="html"><![CDATA[<p>Ember has several great features that are not widely known, like <a href="http://balinterdi.com/2014/05/01/dependency-injection-in-ember-dot-js.html">its Dependency Injection system</a> I wrote about last week.</p>

<p>It has also really handy API methods in hiding. One usually stumbles on them
while looking for something in the superbly commented source code.</p>

<p>I hereby introduce such a handy method and hope to make that into a recurring
thing. Who knows? Eventually this might also grow into a series.</p>

<p>If it does, I would have to find a catchy name for it. "Ember Chispas" came to
mind and rings nice but unfortunately <a href="https://www.youtube.com/user/edisonstew">Jeffrey Biles</a> already has a monopoly on it via his
"Ember Sparks" series. (<em>Chispa</em> is Spanish for spark.) We'll have to talk, Jeffrey :)</p>

<p>Anyway, let's see the first thingie.</p>

<h2>... and in the runloop bind them</h2>

<p>The run loop in Ember deserves its own blog post series, and I am probably not
the one who will write it. (<a href="http://emberjs.com/guides/understanding-ember/run-loop/">The official guide on the subject</a> is a good place
to start, <a href="http://alexmatchneer.com/blog/2013/01/12/everything-you-never-wanted-to-know-about-the-ember-run-loop/">Alex Matchneer's "Everything You Never Wanted to Know About the Ember Run Loop"</a> is more elaborate).</p>

<p>For the sake of this chispa, it suffices to state that any async callback from a 3rd
party javascript library needs to be wrapped into an Ember.run.</p>

<p>Blatantly stealing <a href="https://github.com/emberjs/ember.js/blob/24dcb0c566284a7aa926e701d33f40717264b9b1/packages_es6/ember-metal/lib/run_loop.js#L153">the example from the source code</a>, here is how this is done:</p>

<p>```javascript
var that = this;
jQuery(window).on('resize', function(){
  Ember.run(function(){</p>

<pre><code>that.handleResize();
</code></pre>

<p>  });
});
```</p>

<p>See that beautiful <code>var that=this;</code>? It can be got ridden of via <code>Ember.run.bind</code>:</p>

<p><code>javascript
jQuery(window).on('resize', Ember.run.bind(this, this.handleResize));
</code></p>

<p>Less code to write and all the mustaches are gone (not that there is anything
wrong with &#123;&#123;mustaches&#125;&#125;, of course).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dependency injection in Ember.js - First steps]]></title>
    <link href="http://balinterdi.com/2014/05/01/dependency-injection-in-ember-dot-js.html"/>
    <updated>2014-05-01T08:38:00+02:00</updated>
    <id>http://balinterdi.com/2014/05/01/dependency-injection-in-ember-dot-js</id>
    <content type="html"><![CDATA[<p>Dependency injection (DI) is a less-known, yet powerful feature of the framework
we know and love called Ember.js. It works through the container and is
comprised of two parts: <em>registration</em> and <em>injection</em>.</p>

<p>The framework itself uses it so that the objects instantiated through the
container have the dependencies correctly initialized on them (for the
theoretical programmers out there, the Ember DI system is thus probably
considered a construction-time DI). The API methods are exposed to application
developers for them to register and inject their own objects.</p>

<p>In this first blog post, I'll introduce the main concepts. In a couple of
further blog posts I intend to dig deeper, give examples of what it can be used
for and show a few gotchas.</p>

<h3>Step 1 - Registration</h3>

<p>To be able to inject an entity onto others it first has to be registered on the
container. Think of the container as the birthplace of objects in Ember. It
knows how to instantiate objects and look up factories by their name.</p>

<p>Throughout the post, I'll use the example of a store. If you have worked with
ember-data, the store is the principal piece. It creates model objects and
finds them by their type, id or other criteria so you probably want it to be
accessible from routes and controllers alike.</p>

<p>If you have not come through such a store, don't despair. It is but a handy example to
illustrate dependency injection and how it works for a singleton object.</p>

<p>Let's assume we have a reference to the store "class" in a variable called
<code>Store</code>. To register said store, we write the following:</p>

<p>```js
Ember.Application.initializer({
  name: "store",</p>

<p>  initialize: function(container, application) {</p>

<pre><code>container.register('store:main', Store, { singleton: true });
</code></pre>

<p>  }
});
```</p>

<p>The container now knows the store by the name <code>store:main</code>. That is the name it
has to be referred by subsequently. The <code>singleton: true</code> option
instructs the container not to instantiate a new object each time but use a
singleton instead.</p>

<h3>Step 2 - Injection</h3>

<p>Once the object/factory is registered, it can be used on other objects in the
application. As mentioned above, a store is best used from controllers and
routes. So let's inject them there:</p>

<p>```js
Ember.Application.initializer({
  name: "injectStore",
  before: "store",</p>

<p>  initialize: function(container, application) {</p>

<pre><code>application.inject('controller', 'store', 'store:main');
application.inject('route', 'store', 'store:main');
</code></pre>

<p>  }
});
```</p>

<p>The main method, <code>application.inject</code> takes as its first argument the object(s)
where we want the injection to happen, then the injected name and then the name
of what should be injected. The "what should be injected" has to be the same
name we had registered the object previously with.</p>

<p>The first parameter, <code>controller</code> and <code>route</code> define what is called a type
injection. This means the injected name will be available on all instances of
the type, all controllers and routes in this case. The injected name is <code>store</code>
and it refers to a single instance of the store class since that's how we
defined it at registration time.</p>

<p>We could also just define a simple injection. In a somewhat hypotethical
example, let's assume we only need the store on the artists route.  We write the
following to achieve that:</p>

<p>```js
Ember.Application.initializer({
  name: "injectStore",
  before: "store",</p>

<p>  initialize: function(container, application) {</p>

<pre><code>application.inject('route:artists', 'store', 'store:main');
</code></pre>

<p>  }
});
```</p>

<h3>Step 3 - Putting the two pieces together</h3>

<p>Let's say we want to create an artist object in a route and that creating
objects happens through the store (as it does in ember-data, e.g). The following
snippets set up the injection:</p>

<p>```js
Ember.Application.initializer({
  name: "store",</p>

<p>  initialize: function(container, application) {</p>

<pre><code>container.register('store:main', App.Store, { singleton: true });
</code></pre>

<p>  }
});</p>

<p>Ember.Application.initializer({
  name: "injectStore",
  before: "store",</p>

<p>  initialize: function(container, application) {</p>

<pre><code>application.inject('route', 'store', 'store:main');
</code></pre>

<p>  }
});
```</p>

<p>This makes the singleton instance of the store available on all routes of the
application so we could, for example, write this:</p>

<p>```js
App.IndexRoute = Ember.Route.extend({
  model: function() {</p>

<pre><code>return this.store.createRecord('artist');
</code></pre>

<p>  }
});
```</p>

<p>I also <a href="http://emberjs.jsbin.com/tufoy/2/edit?html,js,output">created a jsbin</a> to show this in action, although admittedly there is
little action at this point.</p>

<h3>Why DI?</h3>

<p>This is all fine and dandy, but what problems does dependency injection solve?
First and foremost, it decouples the pieces of your application. Dependencies
are not hardcoded but injected at construction time. This makes your components
easier to use together since pieces can be swapped in and out as needed.</p>

<p>It is also the de facto way of adding the objects that are not provided by
Ember.js to your application. The store is an example of such an object but you
can also add analytics integration, a pool of workers and other fancy things
easily.</p>

<p>An added benefit is improved unit testing since you can inject mocks as
cooperators and verify calls made on those.</p>

<p>We are going to look at other aspects of DI in Ember.js in more detail in a next
post. Stay tuned and prepare your mojitos.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Observable path patterns in Ember]]></title>
    <link href="http://balinterdi.com/2014/03/26/property-path-patterns-in-ember-dot-js.html"/>
    <updated>2014-03-26T00:00:00+01:00</updated>
    <id>http://balinterdi.com/2014/03/26/property-path-patterns-in-ember-dot-js</id>
    <content type="html"><![CDATA[<p>Property paths are the heart and soul of Ember.js apps. You use them in
templates and you define dependencies for computed properties and observers
through property paths.</p>

<p>In this post, I concentrate on this latter and show you various ways of
setting up these dependencies through a practical example. There is a <a href="http://emberjs.com/guides/object-model/computed-properties-and-aggregate-data/">pretty good section in the guides</a>
about one path pattern. Here, I intend to cover more (all?) of them.</p>

<h2>Badges are back</h2>

<p>I am going to build on the badges "micro-app" that I had started to develop in
<a href="http://balinterdi.com/2014/03/19/ember-dot-js-getters-and-setters.html">my previous post about getters in setters</a>.</p>

<p>There are two minimal model classes, User and Badge:</p>

<p>```js
App.User  = Ember.Object.extend({
  name: ''
});</p>

<p>App.Badge = Ember.Object.extend({
  name: '',
  score: 0,
  unlocked: false
});
```</p>

<p>We also create a couple of instances to have some data to show and work with:</p>

<p>```js
var cory = App.User.create({ name: "Cory Filibuster" });</p>

<p>var rook = App.Badge.create({
  name: "R00k",
  score: 1,
  unlocked: true
});</p>

<p>var taciturn = App.Badge.create({
  name: "Taciturn",
  score: 10
});</p>

<p>var talkative = App.Badge.create({
  name: "Talkative",
  score: 100
});</p>

<p>var hemingway = App.Badge.create({
  name: "Hemingway",
  score: 1000
});
```</p>

<p>Our application looks like this initally:</p>

<p><img src="/images/posts/ember-property-paths/screenshot-2.png" alt="Initital state" /></p>

<h2>Simple property chain</h2>

<p>The simplest, non-aggregate property path is just a series of names,
connected by dots. This designates a property that you can arrive at by
walking the path, segment by segment, where each of them gets you to another
object until you finally reach the property.</p>

<p>(If a path is very long, you should probably think about the dependencies
between your objects and the structure of your code.)</p>

<p>You see that the profile panel has the user's first name as its header. The
property that gets displayed there can be defined by such a path:</p>

<p>```js
App.IndexController = Ember.ArrayController.extend({
  (...)
  firstName: function() {</p>

<pre><code>return this.get('user.name').split(/\s+/)[0];
</code></pre>

<p>  }.property('user.name'),
});
```</p>

<p>This sets up a computed property (CP) that will be recomputed whenever
<code>user.name</code> changes. The arguments to the <code>property</code> call are called the dependent
keys of the CP and you can pass as many as you would like (although, thanks to
the various property path patterns, you will rarely need a lot).</p>

<p>Now, whenever the name property of the <code>user</code> property on the controller
changes, <code>firstName</code> is recomputed and this change gets propagated to all the
instances where <code>firstName</code> is used (e.g in the header of the panel).</p>

<p>Above that, the <code>user.name</code> key also triggers a change if the <code>user</code> object
itself changes. To see that, we turn to the thing you should only ever use for
demo purposes, the <code>__container__</code> object:</p>

<p><code>js
var maggie = App.User.create({ name: "Maggie Raindance" });
App.__container__.lookup('controller:index').set('user', maggie);
</code></p>

<p>You can see the name change in the header right away:</p>

<p><img src="/images/posts/ember-property-paths/screenshot-1.png" alt="User name changes" /></p>

<h2>Aggregate property paths</h2>

<p>On other occasions, a CP should depend on an array of items. Whenever something
gets added to or removed from the array, the property needs to be updated.</p>

<p>One example of that is the number of badges in the profile panel:</p>

<p>```js
App.IndexController = Ember.ArrayController.extend({
  (...)
  badgeCount: function() {</p>

<pre><code>return this.get('model').length;
</code></pre>

<p>  }.property('model.[]'),
});
```</p>

<p>The model here is the array of badges so when we add another one through the New
badge panel, <code>badgeCount</code> gets its new value:</p>

<p><img src="/images/posts/ember-property-paths/screenshot-3.png" alt="Badge count gets updated" /></p>

<p>What I said about the <code>user.name</code> path triggering an update when the user
changes also holds true here. If the array of badges was swapped out for another
array, it would trigger the recalculation of <code>badgeCount</code>.</p>

<h2>Aggregate property path with a specified property</h2>

<p>There are cases where the value of the CP becomes stale also when the items in
the dependent array stay the same, but a certain property of one of them
changes. Ember has a way to express this very succintly.</p>

<p>The example is the "Total score" in the profile panel:</p>

<p>```js
App.IndexController = Ember.ArrayController.extend({
  (...)
  totalScore: function() {</p>

<pre><code>var sum = function(s1, s2) { return s1 + s2; };
return this.get('model').getEach('score').reduce(sum);
</code></pre>

<p>  }.property('model.@each.score'),
});
```</p>

<p>This is the most inclusive of the patterns we have seen so far. It prompts an
update if the model changes, if any item is added or removed and also if the score of
any item changes. If we type this at the console:</p>

<p><code>js
App.__container__.lookup('controller:index').set('model.lastObject.score', 200);
</code></p>

<p>, then the total score changes accordingly, even though no item was inserted or
deleted:</p>

<p><img src="/images/posts/ember-property-paths/screenshot-4.png" alt="Total score" /></p>

<h2>Brace yourself</h2>

<p>To present the next pattern, let's assume that not all badge scores need to be
tallied to get the total but only the unlocked ones (which makes total sense).
So the dependent keys for <code>totalScore</code> needs to account for that. That's pretty
easy:</p>

<p>```js
App.IndexController = Ember.ArrayController.extend({
  (...)
  totalScore: function() {</p>

<pre><code>var sum = function(s1, s2) { return s1 + s2; };
return this.get('model').filterBy('unlocked').getEach('score').reduce(sum);
</code></pre>

<p>  }.property('model.@each.score', 'model.@each.unlocked'),
});
```</p>

<p>When the second badge is unlocked, the score jumps from 1 to 11 (and the number
of badges from 1 to 2), so the dependent keys work fine:</p>

<p><code>js
App.__container__.lookup('controller:index').get('model').objectAt(1).set('unlocked', true);
</code></p>

<p><img src="/images/posts/ember-property-paths/screenshot-3.png" alt="Unlocked property change triggers update" /></p>

<p>Starting with Ember 1.4.0, though, there is a more concise way to define the
same, called "property brace expansion". It works very similar to argument
expansion in the shell:</p>

<p>```js
App.IndexController = Ember.ArrayController.extend({
  (...)
  totalScore: function() {</p>

<pre><code>var sum = function(s1, s2) { return s1 + s2; };
return this.get('model').filterBy('unlocked').getEach('score').reduce(sum);
</code></pre>

<p>  }.property('model.@each.{score,unlocked}'),
});
```</p>

<p>This establishes that totalScore should be recomputed if <em>either</em> the <code>score</code>
<em>or</em> <code>unlocked</code> properties of any item in the model array changes.</p>

<p>An important restriction of property brace expansion is that the expansion part
can only be placed at the end of the path, so e.g <code>property('{foo,bar}.baz')</code>
will not have the desired effect.</p>

<h2>Computed property macros are the bee's knees</h2>

<p>Computed property macros have several advantages. They are very expressive, very
performant and perhaps most importantly more robust than typing out the property
path patterns by hand where a typo can cause a considerable amount of
head-scratching.</p>

<p>They are also a joy to work with and compose. In fact, all the CP definitions
above can be re-defined by using only macros:</p>

<p><code>js
App.IndexController = Ember.ArrayController.extend({
  (...)
  badgeCount: Ember.computed.alias('unlockedBadges.length'),
  unlockedBadges: Ember.computed.filterBy('model', 'unlocked'),
  unlockedScores: Ember.computed.mapBy('unlockedBadges', 'score'),
  totalScore: Ember.computed.sum('unlockedScores'),
});
</code></p>

<p>They have one big disadvantage, though. It is very hard to use them in a blog
post to explain property path patterns.</p>

<p>(The code presented here can be found as <a href="https://gist.github.com/balinterdi/9772966">a gist on Github</a>)</p>

<p>ps. Yes, <a href="https://www.youtube.com/watch?v=RtBbinpK5XI">that Maggie Raindance.</a>)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ember.js getters and setters]]></title>
    <link href="http://balinterdi.com/2014/03/19/ember-dot-js-getters-and-setters.html"/>
    <updated>2014-03-19T20:53:00+01:00</updated>
    <id>http://balinterdi.com/2014/03/19/ember-dot-js-getters-and-setters</id>
    <content type="html"><![CDATA[<p>To make all the magic fairy-dust sprinkling efficient, like auto-updating
templates and computed properties, Ember uses getters and setters instead of
accessing properties directly the javascript (and dare I say, the Angular) way. At
its most simplest form, it is <code>object.get(property)</code> and <code>object.set(property)</code>.</p>

<p>Howevers, it would not be Ember if we were not provided methods on top of these
primitives to make our hard lives as web developers simpler. In the following
post, I am going to show (some of) these methods through an example, so let's
go.</p>

<h2>Badges, badges, I want more badges</h2>

<p>I am certainly in favor of having badges in every application. Discourse is
actively discoursing <a href="https://meta.discourse.org/t/initial-discourse-badge-design-spec">their badge system</a> so I quickly
sketched out something to get ahead of them.</p>

<p>Let me just paste the code here and then use it to explain what the getter and
setter methods are good for.</p>

<p>You can quickly scroll through the below templates. They are mostly there so
that you get the whole picture. The stuff relevant to this discussion is found
in the javascript code.</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;script type=&quot;text/x-handlebars&quot;&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;panel panel-primary&quot;&gt;
      &lt;div class=&quot;panel-heading&quot;&gt;
        &lt;h3 class=&quot;panel-title&quot;&gt;Your badges, sir/ma'am.&lt;/h3&gt;
      &lt;/div&gt;
      &lt;div class=&quot;panel-body&quot;&gt;
        {{outlet}}
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
 &lt;/script&gt;


&lt;p&gt;</code></pre>
</div>
</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;script type=&quot;text/x-handlebars&quot; data-template-name=&quot;index&quot;&gt;
  &lt;ul class=&quot;list-group&quot;&gt;
    {{#each badge in arrangedContent}}
      &lt;li {{bind-attr class=&quot;:list-group-item badge.unlocked::locked&quot;}}&gt;
        {{badge.name}}
        &lt;span class=&quot;badge&quot;&gt;{{badge.score}}&lt;/span&gt;
      &lt;/li&gt;
    {{/each}}
    &lt;li class=&quot;list-group-item&quot;&gt;
      &lt;em&gt;Total:&lt;/em&gt;
      &lt;span class=&quot;pull-right&quot;&gt;{{totalScore}}&lt;/span&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
  &lt;div id=&quot;new-badge&quot; class=&quot;row&quot;&gt;
    &lt;span class=&quot;col-xs-6&quot;&gt;
      {{input class=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;Badge name&quot; value=name}}
    &lt;/span&gt;
    &lt;span class=&quot;col-xs-4&quot;&gt;
      {{input class=&quot;small-input&quot; type=&quot;text&quot; placeholder=&quot;Score&quot; value=score action=&quot;addBadge&quot;}}
    &lt;/span&gt;
    &lt;span class=&quot;col-xs-2&quot;&gt;
      &lt;button class=&quot;btn btn-primary btn-sm pull-right&quot; type=&quot;button&quot;
          {{action &quot;addBadge&quot;}}&gt;
          Add
      &lt;/button&gt;
    &lt;/span&gt;
  &lt;/div&gt;
  &lt;div id=&quot;unlock-all&quot; class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-xs-12&quot;&gt;
      &lt;button class=&quot;btn btn-danger btn-md&quot; type=&quot;button&quot;
        {{action &quot;unlockAll&quot;}}&gt;
        Unlock all
      &lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/script&gt;


&lt;p&gt;</code></pre>
</div>
</p>

<p>First, the badge class is defined and some badges created so that we have something to work with:</p>

<p>```js
App = Ember.Application.create();</p>

<p>App.Badge = Ember.Object.extend({
  name: '',
  score: 0,
  unlocked: false
});</p>

<p>var rook = App.Badge.create({
  name: "R00k",
  score: 1,
  unlocked: true
});</p>

<p>var talkative = App.Badge.create({
  name: "Talkative",
  score: 10
});</p>

<p>var hemingway = App.Badge.create({
  name: "Hemingway",
  score: 1000
});</p>

<p>App.Router.map(function() {
});</p>

<p>App.IndexRoute = Ember.Route.extend({
  model: function() {</p>

<pre><code>return [rook, talkative, hemingway];
</code></pre>

<p>  }
});
```</p>

<h3>getProperties and setProperties</h3>

<p>The first couple of methods come handy when working with a single object but
multiple properties.</p>

<p>``` js
App.IndexController = Ember.ArrayController.extend({
  sortProperties: ['score'],
  sortAscending: true,</p>

<p>  (...)</p>

<p>  actions: {</p>

<pre><code>addBadge: function() {
  var newBadgeProperties = this.getProperties(['name', 'score']);
  newBadgeProperties.score = parseInt(newBadgeProperties.score, 10);

  var newBadge = App.Badge.create(newBadgeProperties);
  this.get('model').pushObject(newBadge);
  this.setProperties({ name: '', score: '' });
},

(...)
</code></pre>

<p>  }
});
```</p>

<p>On line 9, we want to create a new object with the values provided in the input
boxes (addBadge is the action that gets triggered when the Add button is
clicked, check the template). <code>getProperties</code> will create a javascript object
creating key-value pairs for the passed properties. So the above might e.g yield
<code>{ name: "Silent Bob", score: "2" }</code>. That gets directly passed in to create a
new badge object.</p>

<p>On line 14, we use the mutating pair of <code>getProperties</code> to reset the input
fields. Pretty straightforward.</p>

<h3>getEach and setEach</h3>

<p>Ember has us covered when we are working with an array and want to get (or set)
the same property of each item.</p>

<p>``` js
App.IndexController = Ember.ArrayController.extend({
  sortProperties: ['score'],
  sortAscending: true,</p>

<p>  totalScore: function() {</p>

<pre><code>var sum = function(s1, s2) { return s1 + s2; };
return this.get('model').getEach('score').reduce(sum);
</code></pre>

<p>  }.property('model.@each.score'),</p>

<p>  actions: {</p>

<pre><code>(...)

unlockAll: function() {
  this.get('model').setEach('unlocked', true);
}
</code></pre>

<p>  }
});
```</p>

<p>When the "Unlock all" button launches the <code>unlockAll</code> action, it calls <code>setEach</code>
on the badges (line 14), making all of them unlocked (you can verify this in the
demo by seeing the color of the badge names turn darker - their css class has
been updated). Another advange of <code>setEach</code> is that it guards against calling
<code>set</code> on null or undefined values.</p>

<p>You might know the reader counterpart, <code>getEach</code> as <code>mapBy</code>. It goes through the
array and makes another array by getting the passed property on each item. So in
the above example (line 7), we first collect the score for each badge and then
sum them up by way of reduction. (A shiny example of a non-distributed
map-reduce :) ).</p>

<h3>A macro can make nice code nicer</h3>

<p>I <a href="http://balinterdi.com/2014/03/05/sorting-arrays-in-ember-dot-js-by-various-criteria.html">have used a reduce computed macro</a> before to set up sorting.
I have gotten the hang of it and realized I could use another couple of them
to make the above code simpler (and more performant):</p>

<p>``` js
App.IndexController = Ember.ArrayController.extend({
  sortProperties: ['score'],
  sortAscending: true,</p>

<p>  scores: Ember.computed.mapBy('model', 'score'),
  totalScore: Ember.computed.sum('scores'),</p>

<p>  (...)
});
```</p>

<p>The problem is that the subject under discussion, <code>getEach</code> is gone now, so
pretend you did not see this.</p>

<p>Finally, here is the jsbin, should you decide to play around with it:</p>

<p><a class="jsbin-embed" href="http://emberjs.jsbin.com/qivah/4/embed?html,js,output">Getter and Setters</a><script src="http://static.jsbin.com/js/embed.js"></script></p>

<p>I hope some of that sticks and you'll write less "bare" gets and sets.</p>
]]></content>
  </entry>
  
</feed>
