<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ember.js | Balint Erdi]]></title>
  <link href="http://balinterdi.com/blog/categories/ember-js/atom.xml" rel="self"/>
  <link href="http://balinterdi.com/"/>
  <updated>2014-02-26T11:06:35+01:00</updated>
  <id>http://balinterdi.com/</id>
  <author>
    <name><![CDATA[Balint Erdi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A common resource route pattern in Ember.js]]></title>
    <link href="http://balinterdi.com/2014/02/26/a-common-resource-route-pattern-in-ember-dot-js.html"/>
    <updated>2014-02-26T00:01:00+01:00</updated>
    <id>http://balinterdi.com/2014/02/26/a-common-resource-route-pattern-in-ember-dot-js</id>
    <content type="html"><![CDATA[<h2>Intro</h2>

<p>A very common pattern in web applications, be them server- or client side, is
resource URLs. We might have a list of users that we want to show at <code>/users</code> and
then different pages related to the user which is encoded in the URL. These
might be e.g <code>/users/dave-hopkins/activity</code> and <code>/users/dave-hopkins/followers</code>.</p>

<p>The pattern is a top-level URL to list all the resource instances, and then
separate pages to display pieces of information regarding specific resource
instances.</p>

<h2>Artists and songs</h2>

<p>That's exactly what I did for the <a href="https://github.com/balinterdi/rock-and-roll/releases/tag/episode-7">the Rock &amp; Roll application</a>,
where the routes were defined as such:</p>

<p>``` js
App.Router.map(function() {
  this.resource('artists', function() {</p>

<pre><code>this.route('songs', { path: ':slug' });
</code></pre>

<p>  });
});
```</p>

<p>The simplest thing that works. However, the above is not ideal especially when
more pages (or views, if you will) are added below the <code>artists</code> resource route.
That's because the singular artist instance is encoded in the <code>songs</code> route, by
having its identifier (in this case, slug) in the path of that route.</p>

<p>Imagine we need to add additional info about each band. Just blindly extending
the above URL scheme, this would become:</p>

<p>``` js
App.Router.map(function() {
  this.resource('artists', function() {</p>

<pre><code>this.route('songs', { path: ':slug/songs' });
this.route('info',  { path: ':slug/info' });
</code></pre>

<p>  });
});
```</p>

<p>The cracks start to show. The artist for both the <code>artists.songs</code> and the
<code>artists.info</code> routes would have to be fetched in both routes, with identical
code. Nested routes -and how it lends itself to a nested UI- is truly
a masterpiece, a shining emerarld on Ember's crown. It would be a pity not to
take advantage of it.</p>

<h2>DRY up those routes</h2>

<p>So we established that the problem is having the artist "encoded" in all routes
below the top-level <code>artists</code> resource. The solution is consequently pretty
straightforward -this always seems to be the case in retrospective-, let's
extract the path segment that represents the artist:</p>

<p>``` js
App.Router.map(function() {
  this.resource('artists', function() {</p>

<pre><code>this.resource('artist', { path: ':slug' }, function() {
  this.route('songs');
});
</code></pre>

<p>  });
});
```</p>

<p>With the introduction of the <code>artist</code> resource, the duplication is gone, but we
are not done yet. First, we have to define the route and set up its model hook.
Second, since the "routing table" has changed, we'll have to adjust route names
and code that uses them. Since the naming conventions in Ember have the route
names as their basis, we'll probably have to change code in several places.</p>

<h2>Route changes</h2>

<p>Resource routes reset the routing namespace, so the route that corresponds to
the <code>artist</code> route name in the table is App.ArtistRoute:</p>

<p>``` js
App.ArtistRoute = Ember.Route.extend({
  model: function(params) {</p>

<pre><code>return Ember.RSVP.Promise(function(resolve, reject) {
  App.Adapter.ajax('/artists/' + params.slug).then(function(data) {
    resolve(App.Artist.createRecord(data));
  }, function(error) {
    reject(error);
  });
});
</code></pre>

<p>  }
});
```</p>

<p>That is exactly what we had for <code>App.ArtistsSongsRoute</code> in the previous version,
which makes sense. The artist is now fetched one route level higher.</p>

<p>For simple, non-resource routes, the name of the route is the name of the
resource route above (if it exists) plus the name of the route itself. In this
case, the route name is <code>artist.songs</code> which gets resolved as
<code>App.ArtistSongsRoute</code>):</p>

<p>``` js
App.ArtistSongsRoute = Ember.Route.extend({
  model: function(params) {</p>

<pre><code>return this.modelFor('artist').get('songs');
</code></pre>

<p>  },</p>

<p>  setupController: function(controller, model) {</p>

<pre><code>this._super(controller, model);
controller.set('artist', this.modelFor('artist'));
</code></pre>

<p>  },
  (...)
});
```</p>

<p>The first interesting thing is <code>modelFor</code>. It gets the model for another,
already resolved route. In Ember route models are resolved stepping down
from the top-level application route. That means that at this point we can be
certain that the <code>artist</code> route already has its model, the artist instance
resolved.</p>

<p>The model of this route is simply the songs belonging to that artist.</p>

<p>The other interesting bit is <code>setupController</code>. We have already <a href="http://balinterdi.com/2014/01/14/how-real-time-updates-work-in-discourse.html">come across this
hook before</a>; it is the place to do additional
setup -above fetching the model and deciding which template to render- for the
controller. Since we'll want to display artist-related data in the template, we
store it in an <code>artist</code> property and we make sure to call <code>_super</code>, the
implementation of this hook in <code>Ember.Route</code>, that sets the controller's model
property to the model argument in this method.</p>

<h2>Templates &amp; controllers</h2>

<p>The mechanical part of the routing update is to replace all occurrences of
the <code>artists.songs</code> route name to <code>artist.songs</code>.</p>

<p>What deserves more attention is that the controller for <code>artist.songs</code> now has
the songs of the artist as its model, not the artist itself. That means that we
should adjust the controller type it extends:</p>

<p>```js
App.ArtistSongsController = Ember.ArrayController.extend({
  artist: null,</p>

<p>  newSongPlaceholder: function() {</p>

<pre><code>return 'New ' + this.get('artist.name') + ' song';
</code></pre>

<p>  }.property('artist.name'),</p>

<p>  songCreationStarted: false,
  canCreateSong: function() {</p>

<pre><code>return this.get('songCreationStarted') || this.get('length');
</code></pre>

<p>  }.property('songCreationStarted', 'length'),</p>

<p>  (...)
});
```</p>

<p>All changes are made necessary by the model change. Properties of the artist now
need to be prefixed by <code>artist</code> (e.g <code>name</code> => <code>artist.name</code>) while properties of the
songs no longer need to have the <code>songs</code> prefix since it is the model (e.g
<code>songs.length</code> => <code>length</code>).</p>

<p>This also holds true of the template. To give an example, rendering the
stars for each song can becomes more concise:</p>

<p>{% highlight html %}
{% raw %}</p>

<script type="text/x-handlebars" data-template-name="artist/songs">
  (...)
  {{#each}}
    <div class="list-group-item">
      {{title}}
      {{star-rating item=this rating=rating maxRating=5 setAction="setRating"}}
    </div>
  {{else}}
  (...)
</script>


<p>{% endraw %}
{% endhighlight %}</p>

<p>The #each helper, without parameters, loops through the items in the model of the
template, in our case, the songs, which is exactly what we want.</p>

<p>That wraps up our route sanitizaion. In the next post, we will take advantage of
the benefit that the <code>songs</code> route now has the artist's songs as its model.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Making an Ember.js component more reusable]]></title>
    <link href="http://balinterdi.com/2014/02/12/making-an-emberjs-component-more-reusable.html"/>
    <updated>2014-02-12T07:54:00+01:00</updated>
    <id>http://balinterdi.com/2014/02/12/making-an-emberjs-component-more-reusable</id>
    <content type="html"><![CDATA[<h2>Intro</h2>

<p><a href="/2014/02/05/convert-a-view-into-a-component.html">We saw how to turn the star-rating view into a component</a> to
make it more reusable, and less reliant on its context. Everything that the
component needs to do its job had to be passed in, and that is enough for it to
be reusable not just across screens in your application but also across
different applications.  Or is it? Let's take a look at the component code
again:</p>

<p>``` js
App.StarRatingComponent = Ember.Component.extend({
  classNames: ['rating-panel'],</p>

<p>  fullStars: Ember.computed.alias('item.rating'),
  numStars:  Ember.computed.alias('maxRating'),
  (...)
  actions: {</p>

<pre><code>setRating: function() {
  var newRating = parseInt($(event.target).attr('data-rating'), 10);
  this.get('item').set('rating', newRating);
  this.sendAction('setAction', this.get('item'));
}
</code></pre>

<p>  }
```</p>

<p>Is something assumed about the object whose rating our component will display
and set? I'll give you some time to think about it.</p>

<h2>A glove that fits all hands</h2>

<p>What we assume is that the <code>item</code> that gets passed in has a <code>rating</code> property.
If we really want our component to be used in all Ember applications (why not
reach for the <em>stars</em>?), then this should not be an assumption that we make.
After all, a player in a hockey team might have a <code>score</code> property and not
rating. We could get around that by aliasing <code>score</code> to <code>rating</code> in our
controller:</p>

<p><code>js
App.PlayerController = Ember.ObjectController.extend({
  rating: Ember.computed.alias('score');
});
</code></p>

<p>However, this is inconvenient for the app developer and is only necessary
because the star-rating component is not flexible enough. It's as if I had to
reshape my hand to fit the glove.</p>

<p>So let's make it take the property name as a parameter, too:</p>

<p>{% highlight html %}
{% raw %}</p>

<script type="text/x-handlebars" data-template-name="artists/songs">
  {{#each songs}}
    <div class="list-group-item">
      {{title}}
      {{star-rating item=this ratingProperty="rating" maxRating=5 setAction="setRating"}}
    </div>
  (...)
  {{/each}}
</script>


<p>{% endraw %}
{% endhighlight %}</p>

<p>That was easy, now comes the harder part, the component code. Previously, the
fullStars property of the component was just an alias for <code>item.rating</code>. We
can't do that anymore, since the name of the rating property is only known when
the component is used in a template, and can thus differ in each case.</p>

<p>Did Ember let us down this time? Before, it had kept the fullStars property of
our component in sync with the item's rating. We just sat back and took sips of
our mojito. Now, when the going gets tough, we are on our own.</p>

<p>Well, not really. We are doing some advanced stuff so it's no surprise that we
have to use advanced tools that are not needed in the majority of cases. Ember
has nice lower-level functions to support us.</p>

<p>We have to set up the property synchronization ourselves but it sounds scarier
than it is. We just have to watch when the item's rating (score, points,
etc.) property changes and set the fullStars property to that value:</p>

<p>```js
App.StarRatingComponent = Ember.Component.extend({
  classNames: ['rating-panel'],</p>

<p>  numStars:  Ember.computed.alias('maxRating'),
  fullStars: null,</p>

<p>  didInsertElement: function() {</p>

<pre><code>var property = this.get('ratingProperty');
this.set('fullStars', this.get('item').get(property));
Ember.addObserver(this.get('item'), property, this, this.ratingPropertyDidChange);
</code></pre>

<p>  },</p>

<p>  willDestroyElement: function() {</p>

<pre><code>var property = this.get('ratingProperty');
Ember.removeObserver(this.get('item'), property, this.ratingPropertyDidChange);
</code></pre>

<p>  },</p>

<p>  ratingPropertyDidChange: function(item, ratingProperty) {</p>

<pre><code>this.set('fullStars', item.get(ratingProperty));
</code></pre>

<p>  },
  (...)
}
```</p>

<p>There are several things that might be new to you, dear reader, so let me go
through each of them.</p>

<p>The most important thing is the call to <a href="http://emberjs.com/api/classes/Ember.Observable.html#method_addObserver">'Ember.addObserver(object, property,
context, function)'</a>. Whenever <code>property</code> of <code>object</code> changes, it
calls <code>function</code> with <code>context</code> as its <code>this</code>. (Providing a <code>context</code> is
optional).</p>

<p>The observer function (<code>ratingPropertyDidChange</code>) gets the object that was
changed as its first parameter and the property name that was changed. In this
case, it does not have to do anything else but set the <code>fullStars</code> property of
the component to the new value of the item's rating property.</p>

<p>The observer is set up in the <code>didInsertElement</code> function. It is a handy
lifecycle-event for Ember views (and thus components) which gets called after
the view has been inserted into the DOM. This time, we don't need it to be in
the DOM already but it serves as a convenient way to add the observer.</p>

<p>Lastly, since the observer was added manually, it has to be torn down manually,
too, when it is no longer needed. We do this in <code>willDestroyElement</code>, another
view lifecycle event which gets called before the element gets removed from the
DOM. Also, the code comments mention the following about <code>willDestroyElement</code>:</p>

<pre><code>If you write a `willDestroyElement()` handler, you can assume that your
`didInsertElement()` handler was called earlier for the same element.
</code></pre>

<p>This makes <code>didInsertElement</code> - <code>willDestroyElement</code> a perfect pair for manually
setting up and tearing down event handlers (or observers) even if no DOM
manipulation has to be carried out.</p>

<p>I've made a jsbin to show how the star-rating component can now be used with
a <code>score</code> property while the component code stays identical:</p>

<p><a class="jsbin-embed" href="http://emberjs.jsbin.com/sokov/4/embed?html,js,output">Reusable Star Rating component</a><script src="http://static.jsbin.com/js/embed.js"></script></p>

<h3>Conclusion</h3>

<p>We now have a star-rating component that is general enough to be used in all
contexts. Go ahead and use it in your Ember app and let me know if I missed
something.</p>

<p>Actually, there are a couple of featurettes -unrelated to its flexibility, as
far as I see- we can add which I might come back to.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Convert a view into a component]]></title>
    <link href="http://balinterdi.com/2014/02/05/convert-a-view-into-a-component.html"/>
    <updated>2014-02-05T09:44:00+01:00</updated>
    <id>http://balinterdi.com/2014/02/05/convert-a-view-into-a-component</id>
    <content type="html"><![CDATA[<h2>Intro to components in Ember</h2>

<p>Components landed in <a href="http://emberjs.com/blog/2013/06/23/ember-1-0-rc6.html">Ember in 1.0.rc6</a>, in June 2013. They are reusable widgets
that are built on top of HTML and provide a richer functionality. For the sake
of reusability, they are isolated from their surroundings, and -as opposed to
views- do not have access to their context. Everything a component has to know
from the outside world has to be passed in at creation. Anything it wants to
communicate to the outside world needs to be sent via events (or actions, in
Ember parlance).</p>

<p>Usability is meant not just between different parts of the same application but
across Ember applications, too. Once achieved, it would imply that a component
for a specific task needs to be written once and could be used anywhere, just
like jQuery plugins.</p>

<p>That is an ambitious goal which is to expected from an ambitious framework. We
are not quite there, yet, and <a href="http://discuss.emberjs.com/t/some-ideas-i-had-about-composable-reusable-components/2850">the specifics are still under discussion</a>.
Nevertheless, components are a great thing and you should start using them
today, if you have not already.</p>

<h2>"View".replace("Component")</h2>

<p>Wherever you would use a component today, you would have used a view before
components were possible. Views still have their role in an Ember app but when
existing html functionality is enhanced to give a richer, or more complex user
interaction and reusability is important, you should reach for components.</p>

<p>In this post, I'm going to show how to swap out an existing view with a
component. The example I'm going to use is the star rating view from the Rock &amp;
Roll application.</p>

<h2>Star rating component</h2>

<p>Here is what the star rating view looks like:</p>

<p>```js
App.StarRating = Ember.View.extend({
  classNames: ['rating-panel'],
  templateName: 'star-rating',
  rating: Ember.computed.alias('context.rating'),</p>

<p>  fullStars: Ember.computed.alias('rating'),
  numStars:  Ember.computed.alias('maxRating'),</p>

<p>  stars: function() {</p>

<pre><code>var ratings = [];
var fullStars = this.starRange(1, this.get('fullStars'), 'full');
var emptyStars = this.starRange(this.get('fullStars') + 1, this.get('numStars'), 'empty');
Array.prototype.push.apply(ratings, fullStars);
Array.prototype.push.apply(ratings, emptyStars);
return ratings;
</code></pre>

<p>  }.property('fullStars', 'numStars'),</p>

<p>  starRange: function(start, end, type) {</p>

<pre><code>var starsData = [];
for (var i = start; i &lt;= end; i++) {
  starsData.push({ rating: i, full: type === 'full' });
};
return starsData;
</code></pre>

<p>  },
  actions: {</p>

<pre><code>setRating: function() {
  var newRating = $(event.target).data('rating');
  this.set('rating', newRating);
  App.Adapter.ajax('/songs/' + this.get('context.id'), {
    type: 'PUT',
    context: this,
    data: { rating: newRating }
  }).then(function() {
    console.log("Rating updated");
  }, function() {
    alert('Failed to set new rating');
  });
}
</code></pre>

<p>  }
});
```</p>

<p>The most important thing about components is that they do not have access to
their context so any code that does use it needs to be changed.</p>

<p>Back when I wrote the code, I was, somewhat surprisingly, wise enough to use
properties whose semantics reflect the inner operation of the widget, namely
<code>fullStars</code> and <code>numStars</code>. Now we can reap the benefits of this foresight,
because the entire <code>stars</code> and <code>starRange</code> method can remain untouched. It is
only the definition of the <code>fullStars</code> property and the <code>setRating</code> action that
need to change.</p>

<p>Let's quickly sketch up the interface of the component. It will need the <code>item</code>
whose rating it sets/displays, the name of the action it sends to the outer
world when a new rating is set (<code>setAction</code>) and the maximum number of stars.</p>

<p>Having established that, the code transforms to the following:</p>

<p>```js
App.StarRatingComponent = Ember.Component.extend({
  classNames: ['rating-panel'],</p>

<p>  fullStars: Ember.computed.alias('item.rating'),</p>

<p>  (...)</p>

<p>  actions: {</p>

<pre><code>setRating: function() {
  var newRating = parseInt($(event.target).attr('data-rating'), 10);
  this.get('item').set('rating', newRating);
  this.sendAction('setAction', this.get('item'));
}
</code></pre>

<p>  }
});
```</p>

<p><code>fullStars</code> is now the rating property of the item (in our case, a song) that was passed in.</p>

<p>When a star is clicked, the <code>setRating</code> action is triggered. Here, again, the
rating is updated on the item that was passed in. After that, it sends the
action that was passed in as <code>setAction</code> to the controller it was used from,
passing along the item it received.  That is the aforementioned way of sending
messages outside.</p>

<p>(You might wonder what <code>sendAction</code> does. It is a shorthand form of
<code>sendAction(this.get('foo'), ...)</code>.)</p>

<h3>Rendering the component</h3>

<p>The template will only have minor modifications made to it. Here is what it
looked like in its infancy, back when it was a view:</p>

<p>{% highlight html %}
{% raw %}</p>

<script type="text/x-handlebars" data-template-name="star-rating">
  {{#each view.stars}}
    <span {{bind-attr data-rating=rating}}
      {{bind-attr class=":star-rating :glyphicon full:glyphicon-star:glyphicon-star-empty"}}
      {{action "setRating" target=view}}>
    </span>
  {{/each}}
</script>


<p>{% endraw %}
{% endhighlight %}</p>

<p>And here is the shiny, new component form:</p>

<p>{% highlight html %}
{% raw %}</p>

<script type="text/x-handlebars" data-template-name="components/star-rating">
  {{#each stars}}
    <span {{bind-attr data-rating=rating}}
      {{bind-attr class=":star-rating :glyphicon full:glyphicon-star:glyphicon-star-empty"}}
      {{action "setRating"}}>
    </span>
  {{/each}}
</script>


<p>{% endraw %}
{% endhighlight %}</p>

<p>The <code>data-template-name</code> of a component needs to start with <code>components</code> and the
name of the component needs to have a dash in its name to prevent name
collisions with html tags.</p>

<p>The other changes relate to the essence of components, namely that they are not
embedded in their context but work in isolation. That is why we both property
lookups (in <code>#each stars</code>) and action handlers (<code>action "setRating"</code>) both target
the component and thus the target does not need to be defined explicitly.</p>

<p>Even more importantly, an action fired from a component's template will look for
that action in the component but will not bubble to the controller (or route).
That again enhances the component's isolation and thus its reusability and shows
the care that was made when desinging it.</p>

<p>(Unfortunately, if an action by that name is not found on the component, it will
die a silent death which makes debugging more difficult).</p>

<h3>Using the component</h3>

<p>Now comes that part I love most. Using our polished component is just like
calling a function in a language where state is not shared. You pass in
everything the component needs to do its bidding and be done with it:</p>

<p>{% highlight html %}
{% raw %}</p>

<script type="text/x-handlebars" data-template-name="artists/songs">
  (...)
  {{#each songs}}
    <div class="list-group-item">
      {{title}}
      {{star-rating item=this maxRating=5 setAction="setRating"}}
    </div>
  (...)
  {{/each}}
</script>


<p>{% endraw %}
{% endhighlight %}</p>

<h3>Handling the action sent from the component</h3>

<p>We saw how the component will send the action passed in as <code>setAction</code> and pass
along the item (now: song) with it. We just need to handle it the classic Ember
way, either on the controller or the route:</p>

<p>``` js
App.ArtistsSongsRoute = Ember.Route.extend({
  (...)
  actions: {</p>

<pre><code>setRating: function(song) {
  App.Adapter.ajax('/songs/' + song.get('id'), {
    type: 'PUT',
    data: { rating: song.get('rating') }
  }).then(function() {
    console.log("Rating updated");
  }, function() {
    alert('Failed to set new rating');
  });
}
</code></pre>

<p>  }
});
```</p>

<p>Observe how the action to update a song's rating to the backend had to be moved
to the route, instead of the view/component where it does not belong. Another
win for components.</p>

<p>Don't get confused by the two different <code>setRating</code> actions. The first is the
one defined on the component that gets triggered via the action helper from the
component's <strong>template</strong>, the second one is the action name that needs to be
passed in and has to match the name of the event handler on the route.</p>

<h3>Towards better reusability</h3>

<p>I hope you got a taste of why components rock and what steps are taken in their
design towards their reusability. However, it's up to writers of components to
go all the way and make components general enough to fulfill this promise.</p>

<p>That's what I'm going to strive for in a later post.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Promises instead of callbacks]]></title>
    <link href="http://balinterdi.com/2014/01/21/promises-instead-of-callbacks.html"/>
    <updated>2014-01-21T23:30:00+01:00</updated>
    <id>http://balinterdi.com/2014/01/21/promises-instead-of-callbacks</id>
    <content type="html"><![CDATA[<p>A few weeks ago <a href="http://balinterdi.com/2013/12/03/roll-your-own-ember-dot-js-identity-map.html">I built up a very simple identity map</a> to
get rid of a bug in highlighting active links. I introduced promises in order to
leverage the fact that Ember.js blocks in model hooks until the model is
resolved (or rejected).</p>

<p>In this post, I am taking a step back, and converting all the ajax calls that
fetch data from and store data to the backend to use promises. I am also going
to extract the most basic adapter that exists, just to do away with the
repetition in the XHR calls. Once I have these in place, I will able able to
build nice features on top of that.</p>

<h3>App.TheMostBasicAdapterThereIs</h3>

<p>All calls go to the same backend and talk in json so these can be trivially
extracted:</p>

<p>``` js
App.Adapter = {
  ajax: function(path, options) {</p>

<pre><code>var options = options || {};
options.dataType = 'json';
return Ember.$.ajax('http://rock-and-roll-api.herokuapp.com' + path, options)
</code></pre>

<p>  }
}
```</p>

<p>With that out of the way, we can see where these were used, and replace
<code>Ember.$.ajax</code> with <code>App.Adapter.ajax</code>. In the process we are also going to
convert the callback-style code to use promises, a worthwhile
transformation.</p>

<h3>Don't call me back, promise me you'll be there</h3>

<p>Here is what the code for fetching all the artists from the API looks like after
applying the adapter change:</p>

<p>``` js
App.ArtistsRoute = Ember.Route.extend({
  model: function() {</p>

<pre><code>var artistObjects = [];
App.Adapter.ajax('/artists', {
  success: function(artists) {
    artists.forEach(function(data) {
      artistObjects.pushObject(App.Artist.createRecord(data));
    });
  }
});
return artistObjects;
</code></pre>

<p>  },
  (...)
});
```</p>

<p>Notice that the model initially is an empty array and only when the ajax call
returns successfully does that array get filled up and the template rerendered.
Not a big deal in itself, but if in a child route we rely on the array
containing all the artists (e.g when looking up the identity map or using
<a href="https://github.com/emberjs/ember.js/blob/v1.3.0/packages/ember-routing/lib/system/route.js#L997-1012">modelFor</a>), we can be bitten by the async bug. Promises to the
rescue.</p>

<p>As I mentioned in the <a href="http://balinterdi.com/2013/12/03/roll-your-own-ember-dot-js-identity-map.html">identity map post</a>, if a promise is
returned from a model hook, Ember.js will block until the promise is resolved
(or rejected). Let's follow in Ember.js footsteps and convert the above code to
return a promise:</p>

<p>``` js
App.ArtistsRoute = Ember.Route.extend({
  model: function() {</p>

<pre><code>return Ember.RSVP.Promise(function(resolve, reject) {
  App.Adapter.ajax('/artists').then(function(artists) {
    var artistObjects = [];
    artists.forEach(function(data) {
      artistObjects.pushObject(App.Artist.createRecord(data));
    });
    resolve(artistObjects);
  }, function(error) {
    reject(error);
  });
});
</code></pre>

<p>  },
  (...)
});
```</p>

<p>We wrap the promise returned from the <code>App.Adaptar.ajax</code> call in another promise,
which resolves with artist objects instead of the raw data that is returned by
the API. In the rejection handler, we pass along any potential error responses
by rejecting with the same error that we got.</p>

<p>Next, we do the same thing in the child route. We go from here:</p>

<p>``` js
App.ArtistsSongsRoute = Ember.Route.extend({
  model: function(params) {</p>

<pre><code>var artist = App.Artist.create();
App.Adapter.ajax('/artists/' + params.slug, {
  success: function(data) {
    artist.setProperties({
      id: data.id,
      name: data.name,
      songs: App.Artist.extractSongs(data.songs, artist)
    });
  }
});
return artist;
</code></pre>

<p>  },
  (...)
});
```</p>

<p>To here:</p>

<p>``` js
App.ArtistsSongsRoute = Ember.Route.extend({
  model: function(params) {</p>

<pre><code>return Ember.RSVP.Promise(function(resolve, reject) {
  App.Adapter.ajax('/artists/' + params.slug).then(function(data) {
    resolve(App.Artist.createRecord(data));
  }, function(error) {
    reject(error);
  });
});
</code></pre>

<p>  },
  (...)
});
```</p>

<p>To get the "100% promisified" seal, we'll transform the create calls, too. I'll
only show the one to create an artist since creating a song is the same.</p>

<p>``` js
createArtist: function() {
  var name = this.get('controller').get('newName');</p>

<p>  App.Adapter.ajax('/artists', {</p>

<pre><code>type: 'POST',
data: { name: name },
context: this
</code></pre>

<p>  }).then(function(data) {</p>

<pre><code>  var artist = App.Artist.createRecord(data);
  this.modelFor('artists').pushObject(artist);
  this.get('controller').set('newName', '');
  this.transitionTo('artist.songs', artist);
</code></pre>

<p>  }, function(reason) {</p>

<pre><code>alert('Failed to save artist');
</code></pre>

<p>  });
}
```</p>

<p>Here, there is not that much of a difference, the success and error callbacks
are replaced by fulfillment and rejection handlers.</p>

<p>The source code with these changes can be got <a href="https://github.com/balinterdi/rock-and-roll/releases/tag/promisified">here</a>.</p>

<h3>Further studies &amp; posts</h3>

<p>You can acquire a deeper knowledge about promises by reading Domenic Denicola's
<a href="http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/">"You're missing the point of promises"</a> post and using that as a
base for further exploration. Steven Kane's excellent <a href="https://npmjs.org/package/promise-it-wont-hurt">promise-it-wont-hurt package</a>
makes you solve increasingly difficult challenges with promises, which is the best way to learn.</p>

<p>Promisifying all backend calls sets the stage for other routing-related
improvements. Stay tuned for more.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How real-time updates work in Discourse]]></title>
    <link href="http://balinterdi.com/2014/01/14/how-real-time-updates-work-in-discourse.html"/>
    <updated>2014-01-14T11:06:00+01:00</updated>
    <id>http://balinterdi.com/2014/01/14/how-real-time-updates-work-in-discourse</id>
    <content type="html"><![CDATA[<p>Given that I started engaging with web sites in the early 2000s there are still
some things today that I constantly marvel at. One of these things is real-live
update, the absolutely wonderful experience that I'm looking at a page and
it displays a change due to an action of another user right in front of my eyes,
without me hitting refresh.</p>

<p><a href="http://www.discourse.org/">Discourse</a>, being a state-of-the-art forum software does this, too,
and, provided my enthusiasm with all things that bring the web alive, I wanted to
understand how that works. More specifically I wanted to understand how
displaying new posts for the topic I am looking at can work its magic.</p>

<p>In the following post, I want to lead you through the whole process so that you
see exactly how the pieces fit together. In fact, that may be the thing I
enjoy most as a developer. Being able to take apart a complex application and
gain the comprehension of how the individual pieces function and how they are
orchestrated to make a complex system work.</p>

<h3>Tools</h3>

<p>Discourse is built on <a href="http://rubyonrails.org/">Ruby on Rails</a> and <a href="http://emberjs.com">Ember.js</a>, two fantasic
frameworks. Given my recent fascination with front-end development, and Ember.js
in particular, I'll focus on the front-end part here and only talk about the
back-end mechanism as much as it is needed to see the whole picture.</p>

<p><em>Consequently, some knowledge about Ember.js is assumed. You can go through the <a href="http://emberjs.com/guides/getting-ember/">Getting Started</a> guide on the official Ember.js site or -if you prefer
showing to telling- <a href="http://emberjs.balinterdi.com">sign up to my mailing list</a> to watch a series
of screencasts to get a basic grip on Ember.js architecture as we go through the
building of an application.</em></p>

<h3>Message bus</h3>

<p>Discourse uses a ruby gem (library) called <a href="https://github.com/SamSaffron/message_bus">message_bus</a> that
enables listeners to subscribe to any channel of their liking and get notified
about events happening on that channel.</p>

<p>It also includes a <a href="https://github.com/SamSaffron/message_bus/blob/master/assets/message-bus.js">javascript lib</a> to allow connecting to the
message bus from the client-side application. That's what Discourse uses from
the Ember.js app. Let's see how.</p>

<h3>Subscribing to new posts on a topic</h3>

<p>When the user navigates to a topic page, the topic route gets activated and its
hooks run. After resolving the model, the <code>setupController</code> which, as its name
indicates, sets up the controller belonging to the model. It, among other
things, calls the subscribe method on the controller, see below:</p>

<p>``` js
Discourse.TopicRoute = Discourse.Route.extend({
  setupController: function(controller, model) {</p>

<pre><code>(...)
controller.subscribe();
(...)
</code></pre>

<p>  }
```</p>

<p>The controller for the model is Discourse.TopicController, so next we will look into
that:</p>

<p>``` js
Discourse.TopicController = Discourse.ObjectController.extend(..., {
  subscribe: function() {</p>

<pre><code>// Unsubscribe before subscribing again
this.unsubscribe();

var bus = Discourse.MessageBus;

var topicController = this;
bus.subscribe("/topic/" + (this.get('id')), function(data) {
  (...)

  // Add the new post into the stream
  topicController.get('postStream').triggerNewPostInStream(data.id);
});
</code></pre>

<p>  },
  (...)
}
```</p>

<p>The controller subscribes to the channel <code>/topic/&lt;topic_id&gt;</code>. The client polls
the message bus for potential new messages every 15 seconds. You can see the XHR
calls in the console of your browser:</p>

<p><img src="/images/posts/discourse-real-updates/xhr-polls.png" alt="Polling the message bus" /></p>

<p>When something is published to that channel, the callback function gets called
back with the data related to that event. The data, in that case, is going to be
the new post record. When the callback is fired, we call the
triggerNewPostInStream method on the postStream with the id of the post. What
does triggerNewPostInStream do, then? We can check that in the PostStream model.</p>

<p>``` js
/<strong>
  We use this class to keep on top of streaming and filtering posts within a topic.
</strong>/
Discourse.PostStream = Em.Object.extend({
  (...)
  /**</p>

<pre><code>Finds and adds a post to the stream by id. Typically this would happen if we receive a message
from the message bus indicating there's a new post. We'll only insert it if we currently
have no filters.
</code></pre>

<p>  **/
  triggerNewPostInStream: function(postId) {</p>

<pre><code>(...)

var loadedAllPosts = this.get('loadedAllPosts');

if (this.get('stream').indexOf(postId) === -1) {
  this.get('stream').addObject(postId);
  if (loadedAllPosts) { this.appendMore(); }
}
</code></pre>

<p>  },
}
```</p>

<p>The docstring is quite revealing. If the post id is already in the stream, we
don't do anything. If it is not, we add it to the stream (an Ember array). If
the loading of posts has finished, we are ready to append the new posts to the
stream.</p>

<p>Notice we are adding post <em>ids</em>, not actual post records so the next
investigation step is to explore how ids get turned into records.</p>

<p>``` js
/**
  Appends the next window of posts to the stream. Call it when scrolling downwards.</p>

<p>  @method appendMore
  @returns {Ember.Deferred} a promise that's resolved when the posts have been added.
**/
appendMore: function() {
  var self = this;</p>

<p>  // Make sure we can append more posts
  if (!self.get('canAppendMore')) { return Ember.RSVP.resolve(); }</p>

<p>  var postIds = self.get('nextWindow');
  if (Ember.isEmpty(postIds)) { return Ember.RSVP.resolve(); }</p>

<p>  self.set('loadingBelow', true);</p>

<p>  var stopLoading = function() {</p>

<pre><code>self.set('loadingBelow', false);
</code></pre>

<p>  };</p>

<p>  return self.findPostsByIds(postIds).then(function(posts) {</p>

<pre><code>posts.forEach(function(p) {
  self.appendPost(p);
});
stopLoading();
</code></pre>

<p>  }, stopLoading);
},
<code>``
The above</code>appendMore` method is responsible for retrieving the post ids that
have to be added below the currently visible posts and turning these ids into
actual post records.</p>

<p>We are getting close now, but let me speed things up a bit by only explaining the
process but not showing all the code which makes it so that the new post objects
are finally pushed to the <code>posts</code> array from where they will be finally
displayed. (If you are such a code untangler as I am, and would like to see the
code, it is <a href="https://github.com/discourse/discourse/blob/0fd193fac314610d7a93d7b4af84a4bc1e52d03e/app/assets/javascripts/discourse/models/post_stream.js">right here</a>)</p>

<p>What happens is that the new posts get displayed in windows, not one by one.
This window is kept updated in the <code>nextWindow</code> property, from the stream we
pushed post ids into.  It is the slice in this stream that starts at the last
loaded post id and has a maximum length of <code>posts_per_page</code>, a configuration
setting.  This construct also makes it possible, quite ingeniously, for this
same code to load the next batch of posts to the page as the user scrolls down.</p>

<p>The window still contains ids and to fetch the related post records an identity
map (yes, Discourse has its <a href="http://balinterdi.com/2013/12/03/roll-your-own-ember-dot-js-identity-map.html">identity map implementation</a>,
too!) is used via the <code>findPostsByIds</code> method. Once the records are retrieved ,
they are each passed to the <code>appendPost</code> method that just pushes them to the
<code>posts</code> array.</p>

<h3>Displaying the new post in the topic stream</h3>

<p>The only thing remains to be seen for the whole picture to be clear is how the
stream of posts is displayed in the browser. The template that renders the
topic, along with its posts, is <a href="https://github.com/discourse/discourse/blob/0fd193fac314610d7a93d7b4af84a4bc1e52d03e/app/assets/javascripts/discourse/templates/topic.js.handlebars">the topic template</a>.</p>

<p>The relevant part of the template is below:</p>

<p>{% highlight html %}
{% raw %}
{{#unless postStream.loadingFilter}}
  {{cloaked-collection cloakView="post" idProperty="post_number" defaultHeight="200" content=postStream.posts slackRatio=slackRatio}}
{{/unless}}
{% endraw %}
{% endhighlight %}</p>

<p>If the post stream is not loading, we render the posts through the cloaked
collection. I will not go into details about what
<a href="https://github.com/eviltrout/ember-cloaking">cloaked-collection</a> does, (but I highly recommend <a href="http://eviltrout.com/2014/01/04/hiding-offscreen-ember.html">a blog
 post on it by its author, @eviltrout</a>), the important thing in the
current discussion is that it renders the <code>post</code> template (cloakView="post") for
each post from <code>postStream.posts</code> (content=postStream.posts).</p>

<p>That is where the two parts come together. Since a binding is established with
the above handlebars line to the posts property of the postStream, every time
new posts are added (see how in the first part of the walkthrough), the
collection is going to be rerendered and consequently the posts appear in
"real-time". The magic of Ember.js bindings.</p>

<h3>In parting</h3>

<p>I skipped over a couple of things so that this post does not turn into a
chapter of a novel, but I hope that my walkthrough could let you peek behind
the curtains and see how such a miraculous feature is made possible.</p>

<p>The key takeaway is that building with the right tools (namely the message bus and
the solid foundations of Ember.js), which a lot of people have put an enormous
amount of time into, makes such a killer feature within your reach. Not easy,
but definitely doable.</p>
]]></content>
  </entry>
  
</feed>
