<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ember.js | Balint Erdi's blog about Ember.js]]></title>
  <link href="http://balinterdi.com/blog/categories/ember-js/atom.xml" rel="self"/>
  <link href="http://balinterdi.com/"/>
  <updated>2016-03-22T15:55:19+01:00</updated>
  <id>http://balinterdi.com/</id>
  <author>
    <name><![CDATA[I'm all about Ember.js recently]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rock and Roll with Ember.js demo - A public Ember.js example project]]></title>
    <link href="http://balinterdi.com/2016/02/26/rock-and-roll-with-ember-dot-js-demo-a-public-ember-dot-js-example-project.html"/>
    <updated>2016-02-26T11:04:00+01:00</updated>
    <id>http://balinterdi.com/2016/02/26/rock-and-roll-with-ember-dot-js-demo-a-public-ember-dot-js-example-project</id>
    <content type="html"><![CDATA[<p>I have a book called Rock and Roll with Ember.js that has an accompanying
application we develop throughout the book. I also maintain a demo version of
the same app which has been open-source since its inception. However, that demo app
has not received updates for a while now so I decided to do something about
this and spent some time this week on making it a state-of-the-art Ember 2 application.</p>

<p>Here are the main developments I have made:</p>

<ul>
<li><strong>Upgraded it to use the latest Ember, Ember Data and Ember CLI versions, 2.3.0.</strong></li>
<li><strong>Used <a href="http://www.ember-cli-mirage.com/">ember-cli-mirage</a> to seed the app with data and handle "backend" requests.</strong>
(Look, ma', no backend!)
<a href="http://www.ember-cli-mirage.com/">ember-cli-mirage</a> is fantastic addon that lets you set up route handlers,
fixtures, factories and many more to manage your seed data and mock your server
responses, both in development and tests. This was the first time I seriously
used it and I have grown to like it a ton! The author, <a href="https://twitter.com/samselikoff">Sam Selikoff</a>, helped
out tremendously and had an amazing turnaround on a few questions/issues.
I used the latest beta version, 0.2.0-beta.7, which you should definitely
check out and give feedback to Sam.</li>
<li><strong>Made it a modern, idiomatic Ember app.</strong>
It's not just Ember, but also Javascript that evolves at a neck-breaking space
(although to a lesser extent). I used the not-at-all elementary
<a href="https://github.com/abuiles/ember-watson">ember-watson</a> to modernize the Ember app and applied a few manual tweaks
for some of the Javascript parts, like using destructuring and <code>let</code> and <code>const</code>
instead of <code>var</code>.</li>
<li><strong>Deployed it to be publicly accessible.</strong>
Leveraging the most excellent <a href="https://www.pagefronthq.com/">PageFront</a>, the app is now deployed to their
platform. You can see it in action at <a href="https://rarwe-demo.pagefrontapp.com/">https://rarwe-demo.pagefrontapp.com</a>.
This was not even a task, I only needed to issue two commands, one to install
the add-on and one to deploy it.</li>
</ul>


<p>The source lives on Github, at <a href="https://github.com/balinterdi/rarwe-demo">balinterdi/rarwe-demo</a>.</p>

<p>As Mirage can also be used in production (although it's probably not common to
do that), you can check out <a href="https://rarwe-demo.pagefrontapp.com/">the "production" app</a>, with the same seed data I
used in development, and play around with it.</p>

<p>As I mentioned in the introduction, the full version of the app is developed
chapter by chapter in <a href="http://rockandrollwithemberjs.com">the Rock and Roll with Ember book</a>. You can download a
sample chapter below:</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to make an Ember module resolve as another one]]></title>
    <link href="http://balinterdi.com/2016/02/12/how-to-make-an-ember-module-resolve-as-another-one.html"/>
    <updated>2016-02-12T11:12:00+01:00</updated>
    <id>http://balinterdi.com/2016/02/12/how-to-make-an-ember-module-resolve-as-another-one</id>
    <content type="html"><![CDATA[<p>I wanted to write another short, and hopefully useful, post just as I did
recently for <a href="/2016/02/03/binding-style-attributes-warning-in-ember.html">binding the style attribute</a>.</p>

<h2>No configuration is simpler than no configuration</h2>

<p>About a month ago I was working to add authorization to the <a href="http://rockandrollwithemberjs.com">Rock and Roll with
Ember</a> application. I used my favorite addon, <a href="https://github.com/Vestorly/torii">Torii</a>, to help with that
and opted to do the authorization via the <code>google-oauth2-bearer</code> provider.  To
restore the session, Torii looks up the application (Torii) adapter, but the
session initialization and closing code used the <code>google-oauth2-bearer</code>
adapter. So I had two separate files, which I was not happy about and I did not
want to merge everything into the <code>application</code> adapter, as it does not give a
hint about its contents then.</p>

<p>My idea was to make it possible to use another adapter <a href="https://github.com/Vestorly/torii/issues/268">to restore the session
from, via a configuration option</a>. Matthew Beale hinted at a solution that
removes the need for a configuration option and since I haven't seen this
before, I want to share it with you.</p>

<h2>Import from target module, then reexport</h2>

<p>The Ember resolver is the piece that maps qualified full names (like
<code>route:blog</code> or <code>controller:bands</code>) to module names.</p>

<p>In my case, Torii makes the resolver look up <code>torii-adapter:application</code> to
fetch the session from and I wanted this to be resolved to
<code>torii-adapter:google-oauth2-bearer</code>. In the Ember CLI project, that is
equivalent of having the <code>app/torii-adapters/application.js</code> file export
what is exported by <code>app/torii-adapters/google-oauth2-bearer.js</code>.</p>

<p>When phrased like this, the solution is near and I am somewhat embarrassed it
took me a few attempts to arrive at this.</p>

<p>So the solution is to import in <code>app/torii-adapters/application.js</code> what
<code>app/torii-adapters/google-oauth2-bearer.js</code> exports and then reexport it:</p>

<p>```js
// app/torii-adapters/application.js
import GoogleOAuth2BearerAdapter from './google-oauth2-bearer';</p>

<p>export default GoogleOAuth2BearerAdapter;
```</p>

<p><code>js
// app/torii-adapters/google-oauth2-bearer.js
export default Ember.Object.extend({
  (...)
});
</code></p>

<p>Voila, we have "tricked" the resolver without adding any configuration
(and thus complexity) to the addon.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Complex Components in Ember.js - Part 2 - Towards a more reactive component]]></title>
    <link href="http://balinterdi.com/2016/02/04/complex-components-in-ember-dot-js-part-2-towards-a-more-reactive-component.html"/>
    <updated>2016-02-04T08:11:00+01:00</updated>
    <id>http://balinterdi.com/2016/02/04/complex-components-in-ember-dot-js-part-2-towards-a-more-reactive-component</id>
    <content type="html"><![CDATA[<p><em>This is part 2 of my Complex Component Design series. Here are the preceding posts:</em></p>

<ul>
<li><a href="/2015/09/10/complex-component-design-in-ember-intro.html"><strong>Intro</strong></a></li>
<li><a href="/2015/12/18/complex-components-in-ember-dot-js-part-1-analyzing-user-flows.html"><strong>Analyzing User Flows</strong></a></li>
</ul>


<hr />

<p>In <a href="/2015/12/18/complex-components-in-ember-dot-js-part-1-analyzing-user-flows.html">the previous part of this series</a>, the implementation of the main user
flows were explained in detail. I ended the post by saying that I was not
content with the implementation for several reasons, the most crucial of which
was that parent components needed to be passed down to children, so that
children can register themselves with their parent. That, in turn, allowed
parents to reach their children and call methods on them directly instead of
using events, actions and data bindings for communication. In this post, we'll
see how to get rid of these and replace them with more reactive solutions.</p>

<h2>Remove the need for direct access to the input</h2>

<p>Currently, the autocomplete component (the parent) yields itself to its
children. <code>auto-complete-input</code> binds its own <code>autocomplete</code> attribute to it so
that it can register itself with its parent when inserted:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;!-- tests/dummy/app/templates/index.hbs --&gt;


&lt;p&gt;{{#auto-complete&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  on-select=(action &quot;selectArtist&quot;)
  on-input=(action &quot;filterArtists&quot;)
  class=&quot;autocomplete-container&quot; as
    |autocomplete isDropdownOpen inputValue
     toggleDropdown onSelect onInput|}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  &lt;div class=&quot;input-group&quot;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{auto-complete-input
    autocomplete=autocomplete
    value=inputValue
    on-change=onInput
    type=&quot;text&quot;
    class=&quot;combobox input-large form-control&quot;
    placeholder=&quot;Select an artist&quot;}}
(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  &lt;/div&gt;
(...)
{{/auto-complete}}</code></pre>
</div>
</p>

<p>```js
// addon/components/auto-complete-input.js
import Ember from 'ember';</p>

<p>export default Ember.TextField.extend({
  autocomplete: null,</p>

<p>  registerWithAutocomplete: Ember.on('didInsertElement', function() {</p>

<pre><code>this.get('autocomplete').registerInput(this);
</code></pre>

<p>  }),
  (...)
});
```</p>

<p>This is needed when the item is autocompleted and the autocompleted segment is
pre-selected so that the user can type over it if it's not the item they had in
mind:</p>

<p>```js
// addon/components/auto-complete.js
export default Ember.Component.extend({
  (...)
  actions: {</p>

<pre><code>inputDidChange(value) {
  (...)
  Ember.run.scheduleOnce('afterRender', this, function() {
    (...)
    const firstOption = this.get('list.firstOption');
    if (firstOption) {
      const autocompletedLabel = firstOption.get('label');
      this.set('focusedOption', firstOption);
      this.get('on-select')(firstOption.get('item'));
      this.set('inputValue', autocompletedLabel);
      Ember.run.next(() =&gt; {
        this.get('input.element').setSelectionRange(value.length, autocompletedLabel.length);
      });
    }
  });
}
</code></pre>

<p>  }
});
```</p>

<p>On the very last line, the component accesses the <code>input</code> directly, to select
(and highlight) the portion of the item that was autocompleted. That's why we
need the whole registration process.</p>

<p>Since <code>inputDidChange</code> is triggered from the <code>auto-complete-input</code> component, we
could get rid of this direct coupling if there was a way to react to the
action's result in the <code>auto-complete-input</code> itself. That way is called closure
actions.</p>

<h3>Fire, but don't forget</h3>

<p>As opposed to the fire-and-forget nature of "ordinary" (aka. element) actions,
closure actions provide a way to react to the action's outcome at the source,
where the action was fired from.</p>

<p>Since closure actions are functions, they can have return values. If the action
triggers an async action, it's best to return a promise from the upstream
handler to which the event source can attach its handler to.</p>

<p>Let's see how that works in our case.</p>

<p>```js
// addon/components/auto-complete.js
export default Ember.Component.extend({
  (...)
  actions: {</p>

<pre><code>inputDidChange(value) {
  this.get('on-input')(value);
  this.set('isDropdownOpen', true);
  return new Ember.RSVP.Promise((resolve, reject) =&gt; {
    (...)
    Ember.run.scheduleOnce('afterRender', this, function() {
      const firstOption = this.get('list.firstOption');
      if (firstOption) {
        const autocompletedLabel = firstOption.get('label');
        this.set('focusedOption', firstOption);
        this.get('on-select')(firstOption.get('item'));
        this.set('inputValue', autocompletedLabel);
        Ember.run.next(() =&gt; {
          resolve({ start: value.length, end: autocompletedLabel.length });
        });
      }
    });
  });
}
</code></pre>

<p>  }
});
```</p>

<p>The code did not change a lot, but now a promise is returned on line 8. It is
resolved on 18, where <code>start</code> and <code>end</code> designate the cursor positions of the
selection.</p>

<p>The action handler in the <code>auto-complete-input</code> component needs to be modified
to set the selection higlight itself:</p>

<p>```js
// addon/components/auto-complete-input.js
import Ember from 'ember';</p>

<p>export default Ember.TextField.extend({
  valueDidChange: Ember.on('input', function() {</p>

<pre><code>const value = this.$().val();
this.get('on-change')(value).then(({ start, end }) =&gt; {
  this.get('element').setSelectionRange(start, end);
});
</code></pre>

<p>  })
});
```</p>

<p>Calling <code>on-change</code> will call the above <code>inputDidChange</code> function. Instead of
firing the (element) action and forgetting about it, we now call the (closure)
action and then "wait" for the resulting promise to be resolved. Once it does,
we set the selection range.</p>

<p>We could now remove all the registration code and the passing down of the
autocomplete instance to the input component.</p>

<h2>Remove the need for direct access to the list options</h2>

<p>There is still another instance of the same. It serves to give access to the
<code>autocomplete</code> component to the <code>auto-complete-option</code>, through the
<code>auto-complete-list</code>.</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;!-- tests/dummy/app/templates/index.hbs --&gt;


&lt;p&gt;{{#auto-complete&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  on-select=(action &quot;selectArtist&quot;)
  on-input=(action &quot;filterArtists&quot;)
  class=&quot;autocomplete-container&quot; as |autocomplete isDropdownOpen inputValue
                                     toggleDropdown onSelect onInput|}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  &lt;div class=&quot;input-group&quot;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{auto-complete-input
    value=inputValue
    on-change=onInput
    type=&quot;text&quot;
    class=&quot;combobox input-large form-control&quot;
    placeholder=&quot;Select an artist&quot;}}
{{#auto-complete-list autocomplete=autocomplete isVisible=isDropdownOpen class=&quot;typeahead typeahead-long dropdown-menu&quot; as |list|}}
  {{#each matchingArtists as |artist|}}
    {{#auto-complete-option
        id=artist.id
        label=artist.name
        item=artist
        list=list
        on-click=onSelect
        activeId=selectedArtist.id}}
      &amp;lt;a href=&quot;#&quot;&amp;gt;{{artist.name}}&amp;lt;/a&amp;gt;
    {{/auto-complete-option}}
  {{/each}}
{{/auto-complete-list}}
(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  &lt;/div&gt;
{{/auto-complete}}</code></pre>
</div>
</p>

<p>I am not copying all the registration code here as it's very boilerplatey. Each
option, when inserted into the DOM, registers itself with its list, while the
list registers itself with the <code>auto-complete</code> component. The latter has an
options property to access the options:</p>

<p><code>js
// addon/components/auto-complete.js
options: Ember.computed.readOnly('list.options')
</code></p>

<p>This access is needed to be able to cycle through the options by using the
cursor keys and then select one of them by using the return key. Here is the
code that handles keypresses (more precisely, keydowns):</p>

<p>```js
// addon/components/auto-complete.js
export default Ember.Component.extend({
  (...)
  keydownMap: {</p>

<pre><code>8:  'startBackspacing', // backspace
13: 'selectOption',  // return
27: 'closeDropdown', // escape
38: 'focusPrevious', // up key
40: 'focusNext', // down key
</code></pre>

<p>  },</p>

<p>  handleKeydown: Ember.on('keyDown', function(event) {</p>

<pre><code>const map = this.get('keydownMap');
const code = event.keyCode;
const method = map[code];
if (method) {
  return this[method](event);
}
</code></pre>

<p>  }),
  (...)
});
```</p>

<p>This is pretty simple so far. If a key we care about was pressed, we call the
appropriate method to handle it. Let's see how focusing works:</p>

<p>```js
// addon/components/auto-complete.js
export default Ember.Component.extend({
  (...)
  options: Ember.computed.readOnly('list.options'),</p>

<p>  focusPrevious: function(event) {</p>

<pre><code>event.preventDefault();
const focused = this.get('focusedOption');
let index = this.get('options').indexOf(focused);
if (this.get('isDropdownOpen')) {
  index = index - 1;
}
this.focusOptionAtIndex(index);
</code></pre>

<p>  },</p>

<p>  focusNext: function(event) {</p>

<pre><code>event.preventDefault();
let index = 0;
const focused = this.get('focusedOption');
if (focused) {
  index = this.get('options').indexOf(focused);
  if (this.get('isDropdownOpen')) {
    index = index + 1;
  }
}
this.focusOptionAtIndex(index);
</code></pre>

<p>  },</p>

<p>  focusOptionAtIndex: function(index) {</p>

<pre><code>const options = this.get('options');
if (index === -1) {
  index = options.get('length') - 1;
} else if (index === options.get('length')) {
  index = 0;
}
const option = this.get('options').objectAt(index);
if (!option) {
  return;
}
this.focusOption(option);
</code></pre>

<p>  },</p>

<p>  focusOption: function(option) {</p>

<pre><code>const focused = this.get('focusedOption');
if (focused) {
  focused.blur();
}
this.set('focusedOption', option);
option.focus();
</code></pre>

<p>  },
  (...)
});
```</p>

<p><code>focusPrevious</code> and <code>focusNext</code> make sure that the focused index is kept within
the bounds of the avaiable number of options and then focus the previous (or
next) one by calling <code>option.focus()</code> directly (line 49).</p>

<p>There is one more key press concerning related to options, the return key. It
should select the currently focused option, if there is one:</p>

<p>```js
// addon/components/auto-complete.js
export default Ember.Component.extend({
  (...)
  options: Ember.computed.readOnly('list.options'),
  selectOption: function(event) {</p>

<pre><code>event.preventDefault();
const focused = this.get('focusedOption');
if (focused) {
  this.send('selectItem', focused.get('item'), focused.get('label'));
}
this.set('isDropdownOpen', false);
</code></pre>

<p>  },
});
```</p>

<p>This code also leverages the access to the options, indirectly through
<code>this.get('focusedOption')</code>. Furthermore, it assumes that each option has an
<code>item</code> and <code>label</code> properties. Not stellar.</p>

<p>It won't be a piece of cake to get rid of direct coupling in all of these, so
let's get to it.</p>

<h3>Change the focused option without accessing the options</h3>

<p>In the first step, we'll change the focused option without directly commanding
the options to focus/unfocus. We'll then tackle selecting the focused option.</p>

<p>We can use simple data binding to have the focused option available. By
maintaining and yielding a <code>focusedIndex</code> in the "control center", the
<code>autocomplete</code> component, <code>autocomplete-option</code> components can bind to it and
know whether they are focused or not.</p>

<p>Here is how code the templates need to change:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;!-- addon/templates/components/autocomplete.hbs --&gt;


&lt;p&gt;{{yield isDropdownOpen&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    inputValue
    focusedIndex
    selectedIndex
    (action &quot;toggleDropdown&quot;)
    (action &quot;selectItem&quot;)
    (action &quot;inputDidChange&quot;)}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;!-- tests/dummy/app/templates/index.hbs --&gt;


&lt;p&gt;{{#auto-complete&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  on-select=(action &quot;selectArtist&quot;)
  on-input=(action &quot;filterArtists&quot;)
  options=matchingArtists
  displayProperty=&quot;name&quot;
  class=&quot;autocomplete-container&quot; as |isDropdownOpen inputValue
                                     focusedIndex selectedIndex
                                     toggleDropdown onSelect onInput|}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  &lt;div class=&quot;input-group&quot;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{auto-complete-input
    value=inputValue
    on-change=onInput
    type=&quot;text&quot;
    class=&quot;combobox input-large form-control&quot;
    placeholder=&quot;Select an artist&quot;}}
{{#auto-complete-list
    isVisible=isDropdownOpen
    class=&quot;typeahead typeahead-long dropdown-menu&quot; as |list|}}
  {{#each matchingArtists as |artist index|}}
    {{#auto-complete-option
        label=artist.name
        item=artist
        on-click=onSelect
        isFocused=(eq focusedIndex index)
        isSelected=(eq selectedIndex index)}}
      &amp;lt;a href=&quot;#&quot;&amp;gt;{{artist.name}}&amp;lt;/a&amp;gt;
    {{/auto-complete-option}}
  {{else}}
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;No results.&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  {{/each}}
{{/auto-complete-list}}
(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  &lt;/div&gt;
{{/auto-complete}}</code></pre>
</div>
</p>

<p>Note the new <code>focusedIndex</code> and <code>selectedIndex</code> attributes, yielded by the
top-level component that <code>isFocused</code> and <code>isSelected</code> in the
<code>auto-complete-option</code> are bound to.</p>

<p>The <code>eq</code> helper comes from <a href="https://github.com/jmurphyau/ember-truth-helpers">ember-truth-helpers</a> and will evaluate to true if
its params are equal which is exactly what we want.</p>

<p>The <code>autocomplete</code> component needs to change to manage the new indexes instead
of setting its <code>focusedOption</code> and calling <code>option.set</code> directly:</p>

<p>```js
// addon/components/auto-complete.js
export default Ember.Component.extend({
  (...)
  optionsLength: Ember.computed.readOnly('options.length'),
  focusPrevious: function(event) {</p>

<pre><code>event.preventDefault();
const currentIndex = this.get('focusedIndex');
let newIndex;
if (Ember.isNone(currentIndex)) {
  newIndex = this.get('optionsLength') - 1;
} else if (currentIndex === 0) {
  newIndex = this.get('optionsLength') - 1;
} else {
  newIndex = currentIndex - 1;
}
this.set('focusedIndex', newIndex);
this.set('isDropdownOpen', true);
</code></pre>

<p>  },</p>

<p>  focusNext: function(event) {</p>

<pre><code>event.preventDefault();
const currentIndex = this.get('focusedIndex');
const lastIndex = this.get('optionsLength') - 1;
let newIndex;
if (Ember.isNone(currentIndex)) {
  newIndex = 0;
} else if (currentIndex === lastIndex) {
  newIndex = 0;
} else {
  newIndex = currentIndex + 1;
}
this.set('focusedIndex', newIndex);
this.set('isDropdownOpen', true);
</code></pre>

<p>  },</p>

<p>  selectOption: function(event) {</p>

<pre><code>event.preventDefault();
const focusedIndex = this.get('focusedIndex');
if (Ember.isPresent(focusedIndex)) {
  this.set('selectedIndex', focusedIndex);
}
this.set('isDropdownOpen', false);
</code></pre>

<p>  },
});
```</p>

<p>That is simpler and less intrusive than before. (Setting <code>isDropdown</code> to true
has been added as before the option's <code>focus</code> method did the opening).</p>

<p>What's missing is for the selected item to be sent to the outer world (in other
words, for the <code>selectItem</code> to be triggered). Before, it was done by sending
the <code>selectItem</code> action with the focused option's item and label (see line 9 in
the last snippet of the previous section) but we can no longer indulge in
accessing the options directly. Consequently, it was replaced by setting the
<code>selectedIndex</code> to the <code>focusedIndex</code> (see line 39 above).</p>

<p>The problem now is that <code>selectItem</code> needs to be called with the item and the
label (the name of the selected artist to be set as the input's value) and only
the selected <code>auto-complete-option</code> component has that knowledge. So we need to
set up a way for the <code>auto-complete-option</code> components to know when they become
selected and then call that action. As these components are not the source of
the event that lead to an option being selected by key press, we choose to use
an observer:</p>

<p>```js
// addon/components/auto-complete-option.js
import Ember from 'ember';</p>

<p>export default Ember.Component.extend({
  tagName: 'li',
  classNames: 'ember-autocomplete-option',
  classNameBindings: Ember.String.w('isSelected:active isFocused:focused'),</p>

<p>  label: null,
  item: null,
  'on-click': null,
  isFocused: false,
  isSelected: false,</p>

<p>  didClick: Ember.on('click', function() {</p>

<pre><code>this._selectItem();
</code></pre>

<p>  }),</p>

<p>  didBecomeSelected: Ember.observer('isSelected', function() {</p>

<pre><code>const isSelected = this.get('isSelected');
if (isSelected) {
  this._selectItem();
}
</code></pre>

<p>  }),</p>

<p>  _selectItem() {</p>

<pre><code>const item = this.get('item');
this.get('on-click')(item, this.get('label'));
</code></pre>

<p>  }
});
```</p>

<p>Line 21 and 22 is where the option realizes it has become the selected option,
and then calls the corresponding (closure) action on line 28.</p>

<p>We're done, we got rid of all the direct passing of component instances,
registrations and direct property access and method calling. Even though we're
<a href="http://www.ccs.neu.edu/research/demeter/demeter-method/LawOfDemeter/paper-boy/demeter.pdf">Demeter compliant</a>, there are things that could be improved.</p>

<h3>In the next episode...</h3>

<p>One of these things is the observer. <a href="https://www.youtube.com/watch?v=7PUX27RKCq0">Observers fell out of favor</a> some time
ago, and for a good reason. They can be over eager and lead to scenarios where
it is hard to see what's going on. To prove my point, let me show you a bug I've
just accidentally introduced. I call it the "JPJ is too good to be replaced" bug:</p>

<p><img src="/images/posts/complex-component-design-ember/jpj-too-good-bug.gif" alt="JPJ is too good to be replaced" /></p>

<p>(The code for this series is publicly available on Github <a href="https://github.com/balinterdi/ember-cli-autocomplete">here</a>. I've tagged
where we are now with <a href="https://github.com/balinterdi/ember-cli-autocomplete/releases/tag/ccd-part-two">ccd-part-two</a>.)</p>

<p>So we're not done yet. In the next post of the series, we're going to fix that
bug by replacing the observer and make other worthy improvements. Stay tuned!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Binding style attributes warning in Ember]]></title>
    <link href="http://balinterdi.com/2016/02/03/binding-style-attributes-warning-in-ember.html"/>
    <updated>2016-02-03T09:33:00+01:00</updated>
    <id>http://balinterdi.com/2016/02/03/binding-style-attributes-warning-in-ember</id>
    <content type="html"><![CDATA[<p>One warning Ember might print in your console concerns binding a property to
the <code>style</code> attribute of a DOM element, like this:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;div class=&quot;progress-bar&quot; style=&quot;{{barWidth}}&quot;&gt;...&lt;/div&gt;


&lt;p&gt;</code></pre>
</div>
</p>

<p><div>
  <pre><code class='javascript'>export default Ember.Controller.extend({
  progress: 0,
  barWidth: Ember.computed(&#39;progress&#39;, {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return &#39;width:&#39; + this.get(&#39;progress&#39;) + &#39;%&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  });
});</code></pre>
</div>
</p>

<p>Handlebars escapes all html content put in double curlies but it does not do
that with CSS, and thus the above makes possible a cross-site scripting attack.
That is the reason for the warning and the fix for that is to convert the
property (in the above case, <code>barWidth</code>) to a <code>SafeString</code>, which tells Ember
that the content is safe to display. You should only do that after you have
verified that the content you mark as safe cannot be injected by a malicious
user. <a href="http://emberjs.com/deprecations/v1.x/#toc_binding-style-attributes">The guide</a> describes how to do that:</p>

<p><div>
  <pre><code class='javascript'>export default Ember.Controller.extend({
  progress: 0,
  barWidth: Ember.computed(&#39;progress&#39;, {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return new Ember.Handlebars.SafeString(&#39;width:&#39; + this.get(&#39;progress&#39;) + &#39;%&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  });
});</code></pre>
</div>
</p>

<p>(Alternatively, you can call <code>Ember.String.htmlSafe</code> with the string you want to
mark as safe, to the same effect.)</p>

<p>When I did this conversion in a recent project, though, the warning persisted.
After spending a substantial amount of time pouring over the docs and even
stepping through the warning stacktrace, I still could not find out what was
wrong. What helped (as so many times already) was a good night sleep and taking
another look at it in the morning.</p>

<p>Marking the string as safe was done correctly, but when binding it to the
<code>style</code> attribute, I used double quotes around it, probably inhibiting Ember
from seeing it as a SafeString:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;div class=&quot;progress-bar&quot; style=&quot;{{barWidth}}&quot;&gt;...&lt;/div&gt;


&lt;p&gt;</code></pre>
</div>
</p>

<p>So all I had to do to make the warning go away was to remove the quotes:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;div class=&quot;progress-bar&quot; style={{barWidth}}&gt;...&lt;/div&gt;


&lt;p&gt;</code></pre>
</div>
</p>

<p>I hope this saves you some time if you come across a similar situation in your
work.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rock and Roll with Ember.js updated to use Ember &amp; Co 2.3]]></title>
    <link href="http://balinterdi.com/2016/01/21/rock-and-roll-with-ember-dot-js-updated-to-use-ember-and-co-2-dot-3.html"/>
    <updated>2016-01-21T14:50:00+01:00</updated>
    <id>http://balinterdi.com/2016/01/21/rock-and-roll-with-ember-dot-js-updated-to-use-ember-and-co-2-dot-3</id>
    <content type="html"><![CDATA[<p>I have just released a new update to <a href="http://rockandrollwithemberjs.com">the Rock and Roll Ember.js book</a>,
which brings it up to Ember 2.3.0, ED 2.3.2 and Ember CLI 2.3.0-beta.1.</p>

<p>Other improvements made in this release are:</p>

<ul>
<li>Update the PageFront section as it has now become even simpler to deploy apps to PageFront</li>
<li>Reset the song creation process when switching bands</li>
<li>Use ember-bootstrap and remove the section on manually adding assets to the build</li>
<li>Use consistent quoting in snippets and include <code>import Ember from 'ember'</code> wherever needed.</li>
<li>Remove a few paragraphs that talk about how things were in the past (like <code>bind-attr</code>)</li>
</ul>


<p>Happy reading!</p>
]]></content>
  </entry>
  
</feed>
