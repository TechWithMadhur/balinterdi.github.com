<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ember.js | Balint Erdi's blog about Ember.js]]></title>
  <link href="http://balinterdi.com/blog/categories/ember-js/atom.xml" rel="self"/>
  <link href="http://balinterdi.com/"/>
  <updated>2016-02-09T13:29:14+01:00</updated>
  <id>http://balinterdi.com/</id>
  <author>
    <name><![CDATA[I'm all about Ember.js recently]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Complex Components in Ember.js - Part 2 - Towards a more reactive component]]></title>
    <link href="http://balinterdi.com/2016/02/04/complex-components-in-ember-dot-js-part-2-towards-a-more-reactive-component.html"/>
    <updated>2016-02-04T08:11:00+01:00</updated>
    <id>http://balinterdi.com/2016/02/04/complex-components-in-ember-dot-js-part-2-towards-a-more-reactive-component</id>
    <content type="html"><![CDATA[<p><em>This is part 2 of my Complex Component Design series. Here are the preceding posts:</em></p>

<ul>
<li><a href="/2015/09/10/complex-component-design-in-ember-intro.html"><strong>Intro</strong></a></li>
<li><a href="/2015/12/18/complex-components-in-ember-dot-js-part-1-analyzing-user-flows.html"><strong>Analyzing User Flows</strong></a></li>
</ul>


<hr />

<p>In <a href="/2015/12/18/complex-components-in-ember-dot-js-part-1-analyzing-user-flows.html">the previous part of this series</a>, the implementation of the main user
flows were explained in detail. I ended the post by saying that I was not
content with the implementation for several reasons, the most crucial of which
was that parent components needed to be passed down to children, so that
children can register themselves with their parent. That, in turn, allowed
parents to reach their children and call methods on them directly instead of
using events, actions and data bindings for communication. In this post, we'll
see how to get rid of these and replace them with more reactive solutions.</p>

<h2>Remove the need for direct access to the input</h2>

<p>Currently, the autocomplete component (the parent) yields itself to its
children. <code>auto-complete-input</code> binds its own <code>autocomplete</code> attribute to it so
that it can register itself with its parent when inserted:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;!-- tests/dummy/app/templates/index.hbs --&gt;


&lt;p&gt;{{#auto-complete&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  on-select=(action &quot;selectArtist&quot;)
  on-input=(action &quot;filterArtists&quot;)
  class=&quot;autocomplete-container&quot; as
    |autocomplete isDropdownOpen inputValue
     toggleDropdown onSelect onInput|}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  &lt;div class=&quot;input-group&quot;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{auto-complete-input
    autocomplete=autocomplete
    value=inputValue
    on-change=onInput
    type=&quot;text&quot;
    class=&quot;combobox input-large form-control&quot;
    placeholder=&quot;Select an artist&quot;}}
(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  &lt;/div&gt;
(...)
{{/auto-complete}}</code></pre>
</div>
</p>

<p>```js
// addon/components/auto-complete-input.js
import Ember from 'ember';</p>

<p>export default Ember.TextField.extend({
  autocomplete: null,</p>

<p>  registerWithAutocomplete: Ember.on('didInsertElement', function() {</p>

<pre><code>this.get('autocomplete').registerInput(this);
</code></pre>

<p>  }),
  (...)
});
```</p>

<p>This is needed when the item is autocompleted and the autocompleted segment is
pre-selected so that the user can type over it if it's not the item they had in
mind:</p>

<p>```js
// addon/components/auto-complete.js
export default Ember.Component.extend({
  (...)
  actions: {</p>

<pre><code>inputDidChange(value) {
  (...)
  Ember.run.scheduleOnce('afterRender', this, function() {
    (...)
    const firstOption = this.get('list.firstOption');
    if (firstOption) {
      const autocompletedLabel = firstOption.get('label');
      this.set('focusedOption', firstOption);
      this.get('on-select')(firstOption.get('item'));
      this.set('inputValue', autocompletedLabel);
      Ember.run.next(() =&gt; {
        this.get('input.element').setSelectionRange(value.length, autocompletedLabel.length);
      });
    }
  });
}
</code></pre>

<p>  }
});
```</p>

<p>On the very last line, the component accesses the <code>input</code> directly, to select
(and highlight) the portion of the item that was autocompleted. That's why we
need the whole registration process.</p>

<p>Since <code>inputDidChange</code> is triggered from the <code>auto-complete-input</code> component, we
could get rid of this direct coupling if there was a way to react to the
action's result in the <code>auto-complete-input</code> itself. That way is called closure
actions.</p>

<h3>Fire, but don't forget</h3>

<p>As opposed to the fire-and-forget nature of "ordinary" (aka. element) actions,
closure actions provide a way to react to the action's outcome at the source,
where the action was fired from.</p>

<p>Since closure actions are functions, they can have return values. If the action
triggers an async action, it's best to return a promise from the upstream
handler to which the event source can attach its handler to.</p>

<p>Let's see how that works in our case.</p>

<p>```js
// addon/components/auto-complete.js
export default Ember.Component.extend({
  (...)
  actions: {</p>

<pre><code>inputDidChange(value) {
  this.get('on-input')(value);
  this.set('isDropdownOpen', true);
  return new Ember.RSVP.Promise((resolve, reject) =&gt; {
    (...)
    Ember.run.scheduleOnce('afterRender', this, function() {
      const firstOption = this.get('list.firstOption');
      if (firstOption) {
        const autocompletedLabel = firstOption.get('label');
        this.set('focusedOption', firstOption);
        this.get('on-select')(firstOption.get('item'));
        this.set('inputValue', autocompletedLabel);
        Ember.run.next(() =&gt; {
          resolve({ start: value.length, end: autocompletedLabel.length });
        });
      }
    });
  });
}
</code></pre>

<p>  }
});
```</p>

<p>The code did not change a lot, but now a promise is returned on line 8. It is
resolved on 18, where <code>start</code> and <code>end</code> designate the cursor positions of the
selection.</p>

<p>The action handler in the <code>auto-complete-input</code> component needs to be modified
to set the selection higlight itself:</p>

<p>```js
// addon/components/auto-complete-input.js
import Ember from 'ember';</p>

<p>export default Ember.TextField.extend({
  valueDidChange: Ember.on('input', function() {</p>

<pre><code>const value = this.$().val();
this.get('on-change')(value).then(({ start, end }) =&gt; {
  this.get('element').setSelectionRange(start, end);
});
</code></pre>

<p>  })
});
```</p>

<p>Calling <code>on-change</code> will call the above <code>inputDidChange</code> function. Instead of
firing the (element) action and forgetting about it, we now call the (closure)
action and then "wait" for the resulting promise to be resolved. Once it does,
we set the selection range.</p>

<p>We could now remove all the registration code and the passing down of the
autocomplete instance to the input component.</p>

<h2>Remove the need for direct access to the list options</h2>

<p>There is still another instance of the same. It serves to give access to the
<code>autocomplete</code> component to the <code>auto-complete-option</code>, through the
<code>auto-complete-list</code>.</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;!-- tests/dummy/app/templates/index.hbs --&gt;


&lt;p&gt;{{#auto-complete&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  on-select=(action &quot;selectArtist&quot;)
  on-input=(action &quot;filterArtists&quot;)
  class=&quot;autocomplete-container&quot; as |autocomplete isDropdownOpen inputValue
                                     toggleDropdown onSelect onInput|}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  &lt;div class=&quot;input-group&quot;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{auto-complete-input
    value=inputValue
    on-change=onInput
    type=&quot;text&quot;
    class=&quot;combobox input-large form-control&quot;
    placeholder=&quot;Select an artist&quot;}}
{{#auto-complete-list autocomplete=autocomplete isVisible=isDropdownOpen class=&quot;typeahead typeahead-long dropdown-menu&quot; as |list|}}
  {{#each matchingArtists as |artist|}}
    {{#auto-complete-option
        id=artist.id
        label=artist.name
        item=artist
        list=list
        on-click=onSelect
        activeId=selectedArtist.id}}
      &amp;lt;a href=&quot;#&quot;&amp;gt;{{artist.name}}&amp;lt;/a&amp;gt;
    {{/auto-complete-option}}
  {{/each}}
{{/auto-complete-list}}
(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  &lt;/div&gt;
{{/auto-complete}}</code></pre>
</div>
</p>

<p>I am not copying all the registration code here as it's very boilerplatey. Each
option, when inserted into the DOM, registers itself with its list, while the
list registers itself with the <code>auto-complete</code> component. The latter has an
options property to access the options:</p>

<p><code>js
// addon/components/auto-complete.js
options: Ember.computed.readOnly('list.options')
</code></p>

<p>This access is needed to be able to cycle through the options by using the
cursor keys and then select one of them by using the return key. Here is the
code that handles keypresses (more precisely, keydowns):</p>

<p>```js
// addon/components/auto-complete.js
export default Ember.Component.extend({
  (...)
  keydownMap: {</p>

<pre><code>8:  'startBackspacing', // backspace
13: 'selectOption',  // return
27: 'closeDropdown', // escape
38: 'focusPrevious', // up key
40: 'focusNext', // down key
</code></pre>

<p>  },</p>

<p>  handleKeydown: Ember.on('keyDown', function(event) {</p>

<pre><code>const map = this.get('keydownMap');
const code = event.keyCode;
const method = map[code];
if (method) {
  return this[method](event);
}
</code></pre>

<p>  }),
  (...)
});
```</p>

<p>This is pretty simple so far. If a key we care about was pressed, we call the
appropriate method to handle it. Let's see how focusing works:</p>

<p>```js
// addon/components/auto-complete.js
export default Ember.Component.extend({
  (...)
  options: Ember.computed.readOnly('list.options'),</p>

<p>  focusPrevious: function(event) {</p>

<pre><code>event.preventDefault();
const focused = this.get('focusedOption');
let index = this.get('options').indexOf(focused);
if (this.get('isDropdownOpen')) {
  index = index - 1;
}
this.focusOptionAtIndex(index);
</code></pre>

<p>  },</p>

<p>  focusNext: function(event) {</p>

<pre><code>event.preventDefault();
let index = 0;
const focused = this.get('focusedOption');
if (focused) {
  index = this.get('options').indexOf(focused);
  if (this.get('isDropdownOpen')) {
    index = index + 1;
  }
}
this.focusOptionAtIndex(index);
</code></pre>

<p>  },</p>

<p>  focusOptionAtIndex: function(index) {</p>

<pre><code>const options = this.get('options');
if (index === -1) {
  index = options.get('length') - 1;
} else if (index === options.get('length')) {
  index = 0;
}
const option = this.get('options').objectAt(index);
if (!option) {
  return;
}
this.focusOption(option);
</code></pre>

<p>  },</p>

<p>  focusOption: function(option) {</p>

<pre><code>const focused = this.get('focusedOption');
if (focused) {
  focused.blur();
}
this.set('focusedOption', option);
option.focus();
</code></pre>

<p>  },
  (...)
});
```</p>

<p><code>focusPrevious</code> and <code>focusNext</code> make sure that the focused index is kept within
the bounds of the avaiable number of options and then focus the previous (or
next) one by calling <code>option.focus()</code> directly (line 49).</p>

<p>There is one more key press concerning related to options, the return key. It
should select the currently focused option, if there is one:</p>

<p>```js
// addon/components/auto-complete.js
export default Ember.Component.extend({
  (...)
  options: Ember.computed.readOnly('list.options'),
  selectOption: function(event) {</p>

<pre><code>event.preventDefault();
const focused = this.get('focusedOption');
if (focused) {
  this.send('selectItem', focused.get('item'), focused.get('label'));
}
this.set('isDropdownOpen', false);
</code></pre>

<p>  },
});
```</p>

<p>This code also leverages the access to the options, indirectly through
<code>this.get('focusedOption')</code>. Furthermore, it assumes that each option has an
<code>item</code> and <code>label</code> properties. Not stellar.</p>

<p>It won't be a piece of cake to get rid of direct coupling in all of these, so
let's get to it.</p>

<h3>Change the focused option without accessing the options</h3>

<p>In the first step, we'll change the focused option without directly commanding
the options to focus/unfocus. We'll then tackle selecting the focused option.</p>

<p>We can use simple data binding to have the focused option available. By
maintaining and yielding a <code>focusedIndex</code> in the "control center", the
<code>autocomplete</code> component, <code>autocomplete-option</code> components can bind to it and
know whether they are focused or not.</p>

<p>Here is how code the templates need to change:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;!-- addon/templates/components/autocomplete.hbs --&gt;


&lt;p&gt;{{yield isDropdownOpen&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    inputValue
    focusedIndex
    selectedIndex
    (action &quot;toggleDropdown&quot;)
    (action &quot;selectItem&quot;)
    (action &quot;inputDidChange&quot;)}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;!-- tests/dummy/app/templates/index.hbs --&gt;


&lt;p&gt;{{#auto-complete&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  on-select=(action &quot;selectArtist&quot;)
  on-input=(action &quot;filterArtists&quot;)
  options=matchingArtists
  displayProperty=&quot;name&quot;
  class=&quot;autocomplete-container&quot; as |isDropdownOpen inputValue
                                     focusedIndex selectedIndex
                                     toggleDropdown onSelect onInput|}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  &lt;div class=&quot;input-group&quot;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{auto-complete-input
    value=inputValue
    on-change=onInput
    type=&quot;text&quot;
    class=&quot;combobox input-large form-control&quot;
    placeholder=&quot;Select an artist&quot;}}
{{#auto-complete-list
    isVisible=isDropdownOpen
    class=&quot;typeahead typeahead-long dropdown-menu&quot; as |list|}}
  {{#each matchingArtists as |artist index|}}
    {{#auto-complete-option
        label=artist.name
        item=artist
        on-click=onSelect
        isFocused=(eq focusedIndex index)
        isSelected=(eq selectedIndex index)}}
      &amp;lt;a href=&quot;#&quot;&amp;gt;{{artist.name}}&amp;lt;/a&amp;gt;
    {{/auto-complete-option}}
  {{else}}
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;No results.&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  {{/each}}
{{/auto-complete-list}}
(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  &lt;/div&gt;
{{/auto-complete}}</code></pre>
</div>
</p>

<p>Note the new <code>focusedIndex</code> and <code>selectedIndex</code> attributes, yielded by the
top-level component that <code>isFocused</code> and <code>isSelected</code> in the
<code>auto-complete-option</code> are bound to.</p>

<p>The <code>eq</code> helper comes from <a href="https://github.com/jmurphyau/ember-truth-helpers">ember-truth-helpers</a> and will evaluate to true if
its params are equal which is exactly what we want.</p>

<p>The <code>autocomplete</code> component needs to change to manage the new indexes instead
of setting its <code>focusedOption</code> and calling <code>option.set</code> directly:</p>

<p>```js
// addon/components/auto-complete.js
export default Ember.Component.extend({
  (...)
  optionsLength: Ember.computed.readOnly('options.length'),
  focusPrevious: function(event) {</p>

<pre><code>event.preventDefault();
const currentIndex = this.get('focusedIndex');
let newIndex;
if (Ember.isNone(currentIndex)) {
  newIndex = this.get('optionsLength') - 1;
} else if (currentIndex === 0) {
  newIndex = this.get('optionsLength') - 1;
} else {
  newIndex = currentIndex - 1;
}
this.set('focusedIndex', newIndex);
this.set('isDropdownOpen', true);
</code></pre>

<p>  },</p>

<p>  focusNext: function(event) {</p>

<pre><code>event.preventDefault();
const currentIndex = this.get('focusedIndex');
const lastIndex = this.get('optionsLength') - 1;
let newIndex;
if (Ember.isNone(currentIndex)) {
  newIndex = 0;
} else if (currentIndex === lastIndex) {
  newIndex = 0;
} else {
  newIndex = currentIndex + 1;
}
this.set('focusedIndex', newIndex);
this.set('isDropdownOpen', true);
</code></pre>

<p>  },</p>

<p>  selectOption: function(event) {</p>

<pre><code>event.preventDefault();
const focusedIndex = this.get('focusedIndex');
if (Ember.isPresent(focusedIndex)) {
  this.set('selectedIndex', focusedIndex);
}
this.set('isDropdownOpen', false);
</code></pre>

<p>  },
});
```</p>

<p>That is simpler and less intrusive than before. (Setting <code>isDropdown</code> to true
has been added as before the option's <code>focus</code> method did the opening).</p>

<p>What's missing is for the selected item to be sent to the outer world (in other
words, for the <code>selectItem</code> to be triggered). Before, it was done by sending
the <code>selectItem</code> action with the focused option's item and label (see line 9 in
the last snippet of the previous section) but we can no longer indulge in
accessing the options directly. Consequently, it was replaced by setting the
<code>selectedIndex</code> to the <code>focusedIndex</code> (see line 39 above).</p>

<p>The problem now is that <code>selectItem</code> needs to be called with the item and the
label (the name of the selected artist to be set as the input's value) and only
the selected <code>auto-complete-option</code> component has that knowledge. So we need to
set up a way for the <code>auto-complete-option</code> components to know when they become
selected and then call that action. As these components are not the source of
the event that lead to an option being selected by key press, we choose to use
an observer:</p>

<p>```js
// addon/components/auto-complete-option.js
import Ember from 'ember';</p>

<p>export default Ember.Component.extend({
  tagName: 'li',
  classNames: 'ember-autocomplete-option',
  classNameBindings: Ember.String.w('isSelected:active isFocused:focused'),</p>

<p>  label: null,
  item: null,
  'on-click': null,
  isFocused: false,
  isSelected: false,</p>

<p>  didClick: Ember.on('click', function() {</p>

<pre><code>this._selectItem();
</code></pre>

<p>  }),</p>

<p>  didBecomeSelected: Ember.observer('isSelected', function() {</p>

<pre><code>const isSelected = this.get('isSelected');
if (isSelected) {
  this._selectItem();
}
</code></pre>

<p>  }),</p>

<p>  _selectItem() {</p>

<pre><code>const item = this.get('item');
this.get('on-click')(item, this.get('label'));
</code></pre>

<p>  }
});
```</p>

<p>Line 21 and 22 is where the option realizes it has become the selected option,
and then calls the corresponding (closure) action on line 28.</p>

<p>We're done, we got rid of all the direct passing of component instances,
registrations and direct property access and method calling. Even though we're
<a href="http://www.ccs.neu.edu/research/demeter/demeter-method/LawOfDemeter/paper-boy/demeter.pdf">Demeter compliant</a>, there are things that could be improved.</p>

<h3>In the next episode...</h3>

<p>One of these things is the observer. <a href="https://www.youtube.com/watch?v=7PUX27RKCq0">Observers fell out of favor</a> some time
ago, and for a good reason. They can be over eager and lead to scenarios where
it is hard to see what's going on. To prove my point, let me show you a bug I've
just accidentally introduced. I call it the "JPJ is too good to be replaced" bug:</p>

<p><img src="/images/posts/complex-component-design-ember/jpj-too-good-bug.gif" alt="JPJ is too good to be replaced" /></p>

<p>(The code for this series is publicly available on Github <a href="https://github.com/balinterdi/ember-cli-autocomplete">here</a>. I've tagged
where we are now with <a href="https://github.com/balinterdi/ember-cli-autocomplete/releases/tag/ccd-part-two">ccd-part-two</a>.)</p>

<p>So we're not done yet. In the next post of the series, we're going to fix that
bug by replacing the observer and make other worthy improvements. Stay tuned!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Binding style attributes warning in Ember]]></title>
    <link href="http://balinterdi.com/2016/02/03/binding-style-attributes-warning-in-ember.html"/>
    <updated>2016-02-03T09:33:00+01:00</updated>
    <id>http://balinterdi.com/2016/02/03/binding-style-attributes-warning-in-ember</id>
    <content type="html"><![CDATA[<p>One warning Ember might print in your console concerns binding a property to
the <code>style</code> attribute of a DOM element, like this:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;div class=&quot;progress-bar&quot; style=&quot;{{barWidth}}&quot;&gt;...&lt;/div&gt;


&lt;p&gt;</code></pre>
</div>
</p>

<p><div>
  <pre><code class='javascript'>export default Ember.Controller.extend({
  progress: 0,
  barWidth: Ember.computed(&#39;progress&#39;, {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return &#39;width:&#39; + this.get(&#39;progress&#39;) + &#39;%&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  });
});</code></pre>
</div>
</p>

<p>Handlebars escapes all html content put in double curlies but it does not do
that with CSS, and thus the above makes possible a cross-site scripting attack.
That is the reason for the warning and the fix for that is to convert the
property (in the above case, <code>barWidth</code>) to a <code>SafeString</code>, which tells Ember
that the content is safe to display. You should only do that after you have
verified that the content you mark as safe cannot be injected by a malicious
user. <a href="http://emberjs.com/deprecations/v1.x/#toc_binding-style-attributes">The guide</a> describes how to do that:</p>

<p><div>
  <pre><code class='javascript'>export default Ember.Controller.extend({
  progress: 0,
  barWidth: Ember.computed(&#39;progress&#39;, {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return new Ember.Handlebars.SafeString(&#39;width:&#39; + this.get(&#39;progress&#39;) + &#39;%&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  });
});</code></pre>
</div>
</p>

<p>(Alternatively, you can call <code>Ember.String.htmlSafe</code> with the string you want to
mark as safe, to the same effect.)</p>

<p>When I did this conversion in a recent project, though, the warning persisted.
After spending a substantial amount of time pouring over the docs and even
stepping through the warning stacktrace, I still could not find out what was
wrong. What helped (as so many times already) was a good night sleep and taking
another look at it in the morning.</p>

<p>Marking the string as safe was done correctly, but when binding it to the
<code>style</code> attribute, I used double quotes around it, probably inhibiting Ember
from seeing it as a SafeString:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;div class=&quot;progress-bar&quot; style=&quot;{{barWidth}}&quot;&gt;...&lt;/div&gt;


&lt;p&gt;</code></pre>
</div>
</p>

<p>So all I had to do to make the warning go away was to remove the quotes:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;div class=&quot;progress-bar&quot; style={{barWidth}}&gt;...&lt;/div&gt;


&lt;p&gt;</code></pre>
</div>
</p>

<p>I hope this saves you some time if you come across a similar situation in your
work.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rock and Roll with Ember.js updated to use Ember &amp; Co 2.3]]></title>
    <link href="http://balinterdi.com/2016/01/21/rock-and-roll-with-ember-dot-js-updated-to-use-ember-and-co-2-dot-3.html"/>
    <updated>2016-01-21T14:50:00+01:00</updated>
    <id>http://balinterdi.com/2016/01/21/rock-and-roll-with-ember-dot-js-updated-to-use-ember-and-co-2-dot-3</id>
    <content type="html"><![CDATA[<p>I have just released a new update to <a href="http://rockandrollwithemberjs.com">the Rock and Roll Ember.js book</a>,
which brings it up to Ember 2.3.0, ED 2.3.2 and Ember CLI 2.3.0-beta.1.</p>

<p>Other improvements made in this release are:</p>

<ul>
<li>Update the PageFront section as it has now become even simpler to deploy apps to PageFront</li>
<li>Reset the song creation process when switching bands</li>
<li>Use ember-bootstrap and remove the section on manually adding assets to the build</li>
<li>Use consistent quoting in snippets and include <code>import Ember from 'ember'</code> wherever needed.</li>
<li>Remove a few paragraphs that talk about how things were in the past (like <code>bind-attr</code>)</li>
</ul>


<p>Happy reading!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Complex Components in Ember.js - Part 1 - Analyzing user flows]]></title>
    <link href="http://balinterdi.com/2015/12/18/complex-components-in-ember-dot-js-part-1-analyzing-user-flows.html"/>
    <updated>2015-12-18T10:25:00+01:00</updated>
    <id>http://balinterdi.com/2015/12/18/complex-components-in-ember-dot-js-part-1-analyzing-user-flows</id>
    <content type="html"><![CDATA[<p>In this post I continue the <a href="/2015/09/10/complex-component-design-in-ember-intro.html">Complex Component Design series</a> I started back in
September. I slightly renamed the series title as the original idea was to
design and develop the component in the parts of the series but since the
component is mostly "done", I prefer to show how it works and how the different
pieces fit together. I think this way of presenting things is still (perhaps
equally) valuable and we'll have a few open issues to work on "together" to
further improve the component.</p>

<p>The component I described in <a href="/2015/09/10/complex-component-design-in-ember-intro.html">the intro post</a> serves to select an item from a
list of items, either via a dropdown or by starting to type its name and then
selecting it. Here is a very short demo about how that looks in practice:</p>

<p><img src="/images/posts/complex-component-design-ember/ember-autocomplete-demo.gif" alt="Selecting an artist" /></p>

<p>We'll go through the main UI flows and see how they are implemented via
communication of the different layers of the component.</p>

<h2>Getting familiar with the component</h2>

<p>The template we'll use (and which the above demo uses) to understand the
functioning of the component looks like this:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;!-- tests/dummy/app/templates/index.hbs --&gt;


&lt;div class=&quot;form-group&quot;&gt;
  &lt;label&gt;Choose an artist&lt;/label&gt;
  {{#auto-complete
        on-select=(action &quot;selectArtist&quot;)
        on-input=(action &quot;filterArtists&quot;)
        class=&quot;autocomplete-container&quot; as |autocomplete isDropdownOpen inputValue
                                           toggleDropdown onSelect onInput|}}
    &lt;div class=&quot;input-group&quot;&gt;
      {{auto-complete-input
          autocomplete=autocomplete
          value=inputValue
          on-change=onInput
          type=&quot;text&quot;
          class=&quot;combobox input-large form-control&quot;
          placeholder=&quot;Select an artist&quot;}}
      {{#auto-complete-list autocomplete=autocomplete isVisible=isDropdownOpen
              class=&quot;typeahead typeahead-long dropdown-menu&quot; as |list|}}
        {{#each matchingArtists as |artist|}}
          {{#auto-complete-option
              id=artist.id
              label=artist.name
              item=artist
              list=list
              on-click=onSelect
              activeId=selectedArtist.id}}
            &lt;a href=&quot;#&quot;&gt;{{artist.name}}&lt;/a&gt;
          {{/auto-complete-option}}
        {{else}}
          &lt;li&gt;&lt;a href=&quot;#&quot;&gt;No results.&lt;/a&gt;&lt;/li&gt;
        {{/each}}
      {{/auto-complete-list}}
      {{#auto-complete-dropdown-toggle on-click=toggleDropdown
              class=&quot;input-group-addon dropdown-toggle&quot;}}
        &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;
      {{/auto-complete-dropdown-toggle}}
    &lt;/div&gt;
  {{/auto-complete}}
&lt;/div&gt;


&lt;p&gt;</code></pre>
</div>
</p>

<p>This might seem somewhat daunting at first but as we grow acquainted with its
details, our intimidation will subside.</p>

<p>The top-level component is <code>auto-complete</code>. This is the "command center", the
piece that manages the "global" state of the whole widget, like whether the
dropdown is visible and what the current value of the input field is.</p>

<p>You might, with good reason, wonder why these are not handled by the
sub-component where it'd feel more appropriate: the current value of the input
field by <code>auto-complete-input</code> and the opened/closed state of the dropdown by
<code>auto-complete-dropdown-toggle</code>.</p>

<p>The answer is that a change in these states can be triggered from multiple
places and that several child components might need to know about them. The
dropdown can be closed by the user clicking on one of the items in the dropdown
(not on the little arrow of the toggle), while the current text in the input can
be modified by inferring the item when the user starts to type (not just by
actually typing out the whole text).</p>

<h3>Data down, actions up - all the way down (and up)</h3>

<p>That slight violation of separation of concerns (or is it at all?) fits
perfectly with the most important component communication paradigm: Data down,
actions up.</p>

<p>The input, when its value changes, sends an action up to its parent, notifying
it of the change. The parent can then react to this, and communicate any data
(state) changes via the attribute bindings it has to the input. This is why
<code>auto-complete</code> needs to handle, or at least access, state that is used
downstream by its sub-components.</p>

<p>The classical way of passing down data (and establishing a binding) from the
parent to the child is through block parameters of the parent component. The
<code>auto-complete</code> component has quite some:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;!-- tests/dummy/app/templates/index.hbs --&gt;


&lt;p&gt;{{#auto-complete&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  on-select=(action &quot;selectArtist&quot;)
  on-input=(action &quot;filterArtists&quot;)
  class=&quot;autocomplete-container&quot; as |autocomplete isDropdownOpen inputValue
                                     toggleDropdown onSelect onInput|}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  (...)
{{/auto-complete}}</code></pre>
</div>
</p>

<p>The block parameters are those found between the pipes, after the <code>as</code> keyword.
You have to look into the component's own template to see where they come from:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;!-- addon/templates/components/auto-complete.hbs --&gt;


&lt;p&gt;{{yield this isDropdownOpen inputValue&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (action &quot;toggleDropdown&quot;) (action &quot;selectItem&quot;) (action &quot;inputDidChange&quot;)}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<p>Parameters are matched by position, so what is yielded in the first position
becomes the first block parameter. In this case, we yield the component itself
as the first parameter, the aforementioned component states as the 2nd and 3rd
and then (closure) actions that will trigger functions in the <code>auto-complete</code>
component when called in one of the child components. These serve as "remote
controls" (a term used by <a href="https://twitter.com/miguelcamba">Miguel Camba</a> in his <a href="https://www.youtube.com/watch?v=6N4qsO22fmw">awesome presentation at
EmberCamp</a>) for child components to control their parent.</p>

<p>The way of upward communication from child components is calling these actions
when appropriate.</p>

<p>We now have sufficient knowledge to follow the implemention of basic user flows,
so let's get into it.</p>

<h2>Understanding UX flows</h2>

<h3>Manual selection from the dropdown</h3>

<p>The most basic thing one can do with the widget is to pop open the list of
options.</p>

<p>I discarded the parts that are not relevant to understand this, so we're left
with the following:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;!-- tests/dummy/app/templates/index.hbs --&gt;


&lt;div class=&quot;form-group&quot;&gt;
  &lt;label&gt;Choose an artist&lt;/label&gt;
  {{#auto-complete
        on-select=(action &quot;selectArtist&quot;)
        on-input=(action &quot;filterArtists&quot;)
        class=&quot;autocomplete-container&quot; as |autocomplete isDropdownOpen inputValue
                                           toggleDropdown onSelect onInput|}}
    &lt;div class=&quot;input-group&quot;&gt;
      {{#auto-complete-list autocomplete=autocomplete isVisible=isDropdownOpen
              class=&quot;typeahead typeahead-long dropdown-menu&quot; as |list|}}
        (...)
      {{/auto-complete-list}}
      {{#auto-complete-dropdown-toggle on-click=toggleDropdown
              class=&quot;input-group-addon dropdown-toggle&quot;}}
        &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;
      {{/auto-complete-dropdown-toggle}}
    &lt;/div&gt;
  {{/auto-complete}}
&lt;/div&gt;


&lt;p&gt;</code></pre>
</div>
</p>

<p>The <code>auto-complete-dropdown-toggle</code> is the component that can be clicked to open
or close the list of items. At a glance it seems like its <code>on-click</code> attribute
is the action that will be triggered when the user clicks it but let's see for
sure:</p>

<p>```js
// addon/components/auto-complete-dropdown-toggle.js
import Ember from 'ember';</p>

<p>export default Ember.Component.extend({
  tagName: 'span',
  classNames: 'ember-autocomplete-toggle',
  'data-dropdown': 'dropdown',
  'on-click': null,</p>

<p>  toggleDropdown: Ember.on('click', function() {</p>

<pre><code>this.get('on-click')();
</code></pre>

<p>  })
});
```</p>

<p>Indeed, it just calls the action that was passed into it, which is
the <code>toggleDropdown</code> action of the topmost <code>auto-complete</code> component:</p>

<p>```js
// addon/components/auto-complete.js
import Ember from 'ember';</p>

<p>export default Ember.Component.extend({
  (...)
  actions: {</p>

<pre><code>toggleDropdown() {
  this.toggleProperty('isDropdownOpen');
},
</code></pre>

<p>  }
});
```</p>

<p>The <code>toggleProperty</code> method flips the value of its parameter, so if it was false
it now becomes true. <code>isDropdownOpen</code> is yielded as a block parameter so when it
becomes true, <code>auto-complete-list</code> will rerender as one of its attributes,
<code>isVisible</code> has changed. That will then open the dropdown:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;!-- tests/dummy/app/templates/index.hbs --&gt;


&lt;div class=&quot;form-group&quot;&gt;
  &lt;label&gt;Choose an artist&lt;/label&gt;
  {{#auto-complete
      (...)
      class=&quot;autocomplete-container&quot; as |autocomplete isDropdownOpen inputValue
                                           toggleDropdown onSelect onInput|}}
    &lt;div class=&quot;input-group&quot;&gt;
      {{#auto-complete-list autocomplete=autocomplete isVisible=isDropdownOpen
              class=&quot;typeahead typeahead-long dropdown-menu&quot; as |list|}}
        (...)
      {{/auto-complete-list}}
    &lt;/div&gt;
  {{/auto-complete}}
&lt;/div&gt;


&lt;p&gt;</code></pre>
</div>
</p>

<p>The same process is triggered when the toggle is clicked again, only this time
<code>isDropdownOpen</code> goes back to false and thus the dropdown is closed.</p>

<h3>Picking an item</h3>

<p>The second feature we'll look at is more like the second half of the first one:
selecting an item by clicking (tapping) on it.</p>

<p>I have again restrained the template to the relevant bits, throwing away the
input and the toggle:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;!-- tests/dummy/app/templates/index.hbs --&gt;


&lt;div class=&quot;form-group&quot;&gt;
  &lt;label&gt;Choose an artist&lt;/label&gt;
  {{#auto-complete
        on-select=(action &quot;selectArtist&quot;)
        on-input=(action &quot;filterArtists&quot;)
        class=&quot;autocomplete-container&quot; as |autocomplete isDropdownOpen inputValue
                                           toggleDropdown onSelect onInput|}}
    &lt;div class=&quot;input-group&quot;&gt;
      (...)
      {{#auto-complete-list autocomplete=autocomplete isVisible=isDropdownOpen
              class=&quot;typeahead typeahead-long dropdown-menu&quot; as |list|}}
        {{#each matchingArtists as |artist|}}
          {{#auto-complete-option
              id=artist.id
              label=artist.name
              item=artist
              list=list
              on-click=onSelect
              activeId=selectedArtist.id}}
            &lt;a href=&quot;#&quot;&gt;{{artist.name}}&lt;/a&gt;
          {{/auto-complete-option}}
        {{else}}
          &lt;li&gt;&lt;a href=&quot;#&quot;&gt;No results.&lt;/a&gt;&lt;/li&gt;
        {{/each}}
      {{/auto-complete-list}}
      (...)
    &lt;/div&gt;
  {{/auto-complete}}
&lt;/div&gt;


&lt;p&gt;</code></pre>
</div>
</p>

<p>When one of the items is clicked, the <code>on-click</code> attribute (which is the
<code>onSelect</code> closure action provided by <code>auto-complete</code>) is called in the
<code>auto-complete-option</code> component:</p>

<p>```js
// addon/components/auto-complete-option.js
import Ember from 'ember';</p>

<p>export default Ember.Component.extend({
  (...)
  selectOption: Ember.on('click', function() {</p>

<pre><code>this.get('on-click')(this.get('item'), this.get('label'));
</code></pre>

<p>  }),
});
```</p>

<p>So where is <code>onSelect</code> defined? It is one of the block parameters yielded by
<code>auto-complete</code>, more precisely the <code>(action "selectItem")</code> action:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;!-- addon/templates/components/auto-complete.hbs --&gt;


&lt;p&gt;{{yield this isDropdownOpen inputValue&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (action &quot;toggleDropdown&quot;) (action &quot;selectItem&quot;) (action &quot;inputDidChange&quot;)}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<p><code>selectItem</code> is quite straightforward:</p>

<p>```js
// addon/components/auto-complete.js
import Ember from 'ember';</p>

<p>export default Ember.Component.extend({
  (...)
  actions: {</p>

<pre><code>selectItem(item, value) {
  this.get('on-select')(item);
  this.set('isDropdownOpen', false);
  this.set('inputValue', value);
},
(...)
</code></pre>

<p>  }
});
```</p>

<p>It first calls the <code>on-select</code> action that was passed into it from the "outside"
(the controller), which just sets <code>selectedArtist</code> to the artist object
encapsulated in the list item. It then sets the <code>isDropdownOpen</code> flag to false
(which, by the mechanism seen in the previous point, closes the list) and sets
the text in the input to the item's label (the artist's name).</p>

<h3>Auto-completing an item</h3>

<p>As the final example, let's see a more complicated use case. When the user
starts to type, the items that do not match the typed string will not be shown
as options. Also, the first matching item will be auto-completed and selected,
and the dropdown will be closed.</p>

<p>No surprises here, the same design principle will be applied as before. Pass
down an action that should be called from a child, then change some property
in the parent component that trickles down to the child which then rerenders
itself because of the changed attribute.</p>

<p>Let's see the relevants parts of the template:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;!-- tests/dummy/app/templates/index.hbs --&gt;


&lt;div class=&quot;form-group&quot;&gt;
  &lt;label&gt;Choose an artist&lt;/label&gt;
  {{#auto-complete
        on-select=(action &quot;selectArtist&quot;)
        on-input=(action &quot;filterArtists&quot;)
        class=&quot;autocomplete-container&quot; as |autocomplete isDropdownOpen inputValue
                                           toggleDropdown onSelect onInput|}}
    &lt;div class=&quot;input-group&quot;&gt;
      {{auto-complete-input
          autocomplete=autocomplete
          value=inputValue
          on-change=onInput
          type=&quot;text&quot;
          class=&quot;combobox input-large form-control&quot;
          placeholder=&quot;Select an artist&quot;}}
      {{#auto-complete-list autocomplete=autocomplete isVisible=isDropdownOpen
              class=&quot;typeahead typeahead-long dropdown-menu&quot; as |list|}}
        {{#each matchingArtists as |artist|}}
          {{#auto-complete-option
              (...)
          {{/auto-complete-option}}
        {{else}}
          &lt;li&gt;&lt;a href=&quot;#&quot;&gt;No results.&lt;/a&gt;&lt;/li&gt;
        {{/each}}
      {{/auto-complete-list}}
      (...)
    &lt;/div&gt;
  {{/auto-complete}}
&lt;/div&gt;


&lt;p&gt;</code></pre>
</div>
</p>

<p>We'll start by the <code>auto-complete-input</code> this time where the <code>input</code> event,
triggered by the user's typing, is handled:</p>

<p>```js
// addon/components/auto-complete-input.js
import Ember from 'ember';</p>

<p>export default Ember.TextField.extend({
  (...)
  valueDidChange: Ember.on('input', function() {</p>

<pre><code>const value = this.$().val();
this.get('on-change')(value);
</code></pre>

<p>  })
});
```</p>

<p>This is almost the exact copy of calling the <code>on-select</code> action we saw before
from <code>auto-complete-option</code>. Here, the <code>on-change</code> function is called that was
passed down from the block param of <code>auto-complete</code>.</p>

<p>If we take a look in the template of <code>auto-complete</code> we see it creates a
<code>(action 'inputDidChange')</code> closure action and yield that, so that should be the
next thing to look at. Here is where most of the stuff happens:</p>

<p>```js
// addon/components/auto-complete.js
import Ember from 'ember';</p>

<p>export default Ember.Component.extend({
  (...)
  actions: {</p>

<pre><code>inputDidChange(value) {
  this.get('on-input')(value);
  this.set('isDropdownOpen', true);
  const firstOption = this.get('list.firstOption');
  if (firstOption) {
    const autocompletedLabel = firstOption.get('label');
    this.get('on-select')(firstOption.get('item'));
    this.set('inputValue', autocompletedLabel);
    this.get('input.element').setSelectionRange(value.length, autocompletedLabel.length);
  }
}
</code></pre>

<p>  }
});
```</p>

<p>We first call the <code>on-input</code> action which filters out the artists that do not
match the typed prefix. The result of that is that <code>matchingArtists</code> will only
contain the artists that do match. The dropdown is then opened to display these
items (or an explanatory blurb if none matches). If there is at least one
matching item, the first one is selected (and becomes <code>selectedArtist</code>).</p>

<p>As an UX improvement, the "inferred" range from the label in the input is
selected, so that the user can continue typing and thus select another artist if
the first one was not what they meant. (See when I type "J" in the demo).</p>

<h3>Design concepts</h3>

<p>I'm not totally happy with the current state of the component because of the
following:</p>

<p>1) The <code>auto-complete</code> component reaches inside the <code>auto-complete-input</code> one
(set in its <code>input</code> property) to call <code>setSelectionRange</code> on it (see the last
code snippet).</p>

<p>2) The same component retrieves the options from the list and gets its <code>item</code>
to select it. Again, this is quite intrusive and will break if the internals of
<code>auto-complete-option</code> change.</p>

<p>3) Still the <code>auto-complete</code> component yields an instance of itself as a block
parameter. This enables "downstream consumers" to access any of its properties
and methods, breaking its encapsulation.</p>

<p>In presenting about these concepts at the <a href="https://www.bigmarker.com/global-ember-meetup/Inside-Ember-Mirage-and-Complex-Component-Design">Global Ember Meetup</a> and at
<a href="http://www.meetup.com/Ember-js-Belgium/events/226904768/">Ember.js Belgium</a>, I said that I like to think about components as the
objects of the UI.  Thinking about them as objects helps to deliver the point
that some (most?) object oriented practices should be applied to components,
too. If this assumption is correct, we can leverage OOP design concepts and
guidelines that we've been developing for decades, giving us a headstart on how
to design (and what to watch out for) complex component hierarchies.</p>

<p>For example, I consider the set of block parameters yielded by a component as
its public API. This means that yielding <code>this</code> from a component's template is
considered bad practice as it breaks encapsulation. In some cases, it's
relatively easy to find a way around it, in others it's much more difficult.
We'll see if I can pull it off in the above case.</p>

<p>As a closing thought, notice how 95% of the feature's implementation relied on
block parameters and closure actions. They are fantastic tools to work with and
I don't know how anything could be achieved without them before they existed.</p>

<h2>Pointers</h2>

<p>Incidentally, <a href="https://twitter.com/miguelcamba">Miguel Camba</a> seems to think about components lately, too. I
already mentioned his fantastic talk at EmberCamp this year called <a href="https://www.youtube.com/watch?v=6N4qsO22fmw">"Composable
components"</a>, but above that he has released <a href="http://www.ember-power-select.com">ember-power-select</a>, which
serves the same purpose as the <code>auto-complete</code> component in my blog post series.</p>

<p>However, it's much more mature and flexible so if you need a select dropdown in
your app, use <code>ember-power-select</code>, as my component is for learning and
demonstration purposes only. That said, I published it on Github under
<a href="https://github.com/balinterdi/ember-cli-autocomplete">balinterdi/ember-cli-autocomplete</a> if you want to take a look or follow
along the blog posts while looking at its source code. I put a tag called
<code>ccd-part-one</code> on the repo for this blog post.</p>

<h2>In the next episode...</h2>

<p>... of the series, I'd like to address (some of) my concerns I mentioned above
and see how to fix them. Stay tuned!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rock and Roll with Ember.js updated to Ember 2.2.0]]></title>
    <link href="http://balinterdi.com/2015/11/23/rock-and-roll-with-ember-dot-js-updated-to-ember-2-dot-2-0.html"/>
    <updated>2015-11-23T20:59:00+01:00</updated>
    <id>http://balinterdi.com/2015/11/23/rock-and-roll-with-ember-dot-js-updated-to-ember-2-dot-2-0</id>
    <content type="html"><![CDATA[<p>I have updated the app developed in the <a href="http://rockandrollwithemberjs.com">Rock and Roll with Ember.js book</a> to
Ember 2.2 and Ember CLI 1.13.12. I also replaced the now defunct Divshot
deployment section with another great &amp; simple deployment option,
<a href="https://www.pagefronthq.com/">PageFront</a>.</p>

<p>Above that, there is a great deal of "bug fixes and stability improvements" in
this release, the list of which can be viewed on <a href="https://github.com/balinterdi/rarwe-issues/issues?q=milestone%3A2.2.0">Github</a>.</p>

<p>Thank you to everybody who reported issues and helped to improve <a href="http://rockandrollwithemberjs.com">the book</a>.</p>
]]></content>
  </entry>
  
</feed>
