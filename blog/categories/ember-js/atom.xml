<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ember.js | Balint Erdi's blog about Ember.js]]></title>
  <link href="http://balinterdi.com/blog/categories/ember-js/atom.xml" rel="self"/>
  <link href="http://balinterdi.com/"/>
  <updated>2016-06-02T11:41:31+02:00</updated>
  <id>http://balinterdi.com/</id>
  <author>
    <name><![CDATA[I'm all about Ember.js recently]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Complex Component Design in Ember - Part 4 - Use the hash helper]]></title>
    <link href="http://balinterdi.com/2016/05/26/complex-component-design-in-ember-part-4-use-the-hash-helper.html"/>
    <updated>2016-05-26T09:21:00+02:00</updated>
    <id>http://balinterdi.com/2016/05/26/complex-component-design-in-ember-part-4-use-the-hash-helper</id>
    <content type="html"><![CDATA[<p><em>This is the fourth and final part of my Complex Component Design series. Here are the preceding posts:</em></p>

<ul>
<li><a href="/2015/09/10/complex-component-design-in-ember-intro.html"><strong>Intro</strong></a></li>
<li><a href="/2015/12/18/complex-components-in-ember-dot-js-part-1-analyzing-user-flows.html"><strong>Part 1 - Analyzing User Flows</strong></a></li>
<li><a href="/2016/02/04/complex-components-in-ember-dot-js-part-2-towards-a-more-reactive-component.html"><strong>Part 2 - Towards a more reactive component</strong></a></li>
<li><a href="/2016/04/08/complex-component-design-in-ember-replace-the-observer.html"><strong>Part 3 - Remove the observer</strong></a></li>
<li><strong>Part 4 - Use the hash helper</strong></li>
</ul>


<p>You can find the code for this post <a href="https://github.com/balinterdi/ember-cli-autocomplete/releases/tag/ccd-part-four">on Github.</a></p>

<hr />

<p>After our last refactoring, the <code>ember-cli-autocomplete</code> component no longer
uses observers. However, the list of parameters the outermost, container
component, <code>auto-complete</code> returns is now unwieldily long:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;!-- tests/dummy/templates/index.hbs --&gt;


&lt;p&gt;{{#auto-complete&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      on-select=(action &quot;selectArtist&quot;)
      on-input=(action &quot;filterArtists&quot;)
      options=matchingArtists
      displayProperty=&quot;name&quot;
      class=&quot;autocomplete-container&quot; as |isDropdownOpen inputValue options
                                         focusedIndex selectedIndex
                                         toggleDropdown onSelect onInput|}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  (...)
{{/auto-complete}}</code></pre>
</div>
</p>

<p>Not only does that look clumsy, it also makes refactoring more difficult and one
always constantly have to flip between the component's template (where params
are yielded from) and the template where the component is used to see if the
position of values match. So how can improve this?</p>

<h2>Components as functions</h2>

<p>To understand several concepts about components, consider them functions.
Putting aside the fact that they can also emit DOM elements, you call them with
a list of arguments, usually, though not exclusively, a collection of key-value
pairs.  The component then does some internal stuff and returns a value from its
template via the <code>yield</code> keyword.</p>

<p>Our current case is another instance when treating them as functions can help us
find the solution. Ask yourself: what would you do if the return value of a
function you wrote grew to a long list of arguments? You would convert the
return value to a key-value collection, such as a hash, wouldn't you?</p>

<p>Well, in Ember's component land, we can do this by using the <code>hash</code> helper,
<a href="http://emberjs.com/blog/2016/01/15/ember-2-3-released.html">introduced in Ember 2.3</a>. It takes a list of key-value pairs at invocation
time and outputs an object (a hash) with them:</p>

<p><div>
  <pre><code class='html'>{{#with (hash firstName=&#39;Mike&#39; lastName=&#39;McCready&#39; instrument=&#39;guitar&#39;) as |musician|}}
  Hello, I&#39;m {{musician.firstName}} {{musician.lastName}} and I play the {{musician.instrument}}.
{{/with}}</code></pre>
</div>
</p>

<p>We can use the <code>hash</code> helper to bring some sanity to the return value of <code>auto-complete</code>
parameters. It currently looks like this:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;!-- addon/templates/components/auto-complete.hbs --&gt;


&lt;p&gt;{{yield isDropdownOpen&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    inputValue
    options
    focusedIndex
    selectedIndex
    (action &quot;toggleDropdown&quot;)
    (action &quot;selectOption&quot;)
    (action &quot;inputDidChange&quot;)}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<p>So we introduce the <code>hash</code> helper to get the following:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;!-- addon/templates/components/auto-complete.hbs --&gt;


&lt;p&gt;{{yield (hash&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;isOpen=isDropdownOpen
inputValue=inputValue
options=options
focusedIndex=focusedIndex
selectedIndex=selectedIndex
toggleDropdown=(action &quot;toggleDropdown&quot;)
onSelect=(action &quot;selectItem&quot;)
onInput=(action &quot;inputDidChange&quot;))}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<h2>Modifying call sites</h2>

<p>Now that the component's return value has changed, we should not forget to
modify the callers, the downstream components that use that value:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;!-- tests/dummy/app/templates/index.hbs --&gt;


&lt;p&gt;{{#auto-complete&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  on-select=(action &quot;selectArtist&quot;)
  on-input=(action &quot;filterArtists&quot;)
  items=matchingArtists
  displayProperty=&quot;name&quot;
  class=&quot;autocomplete-container&quot; as |params|}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  &lt;div class=&quot;input-group&quot;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{auto-complete-input
    value=params.inputValue
    on-change=params.onInput
    type=&quot;text&quot;
    class=&quot;combobox input-large form-control&quot;
    placeholder=&quot;Select an artist&quot;}}
{{#auto-complete-list
    isVisible=params.isOpen
    class=&quot;typeahead typeahead-long dropdown-menu&quot;}}
  {{#each params.options as |option|}}
    {{#auto-complete-option
        index=option.index
        on-click=params.onSelect
        isFocused=(eq params.focusedIndex option.index)
        isSelected=(eq params.selectedIndex option.index)}}
      &amp;lt;a href=&quot;#&quot;&amp;gt;{{option.value}}&amp;lt;/a&amp;gt;
    {{/auto-complete-option}}
  {{else}}
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;No results.&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  {{/each}}
{{/auto-complete-list}}
{{#auto-complete-dropdown-toggle on-click=params.toggleDropdown class=&quot;input-group-addon dropdown-toggle&quot;}}
  &amp;lt;span class=&quot;caret&quot;&amp;gt;&amp;lt;/span&amp;gt;
{{/auto-complete-dropdown-toggle}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  &lt;/div&gt;
{{/auto-complete}}</code></pre>
</div>
</p>

<p>Instead of the long list of parameters, <code>auto-complete</code> now yields a single hash
parameter (called <code>params</code> above), whose keys are used in the child components
(<code>params.isOpen</code>, <code>params.options</code>, etc.)</p>

<h2>Polyfill it</h2>

<p>Since we want our component to be usable not only in Ember >=2.3 applications,
where the <code>hash</code> helper is built in, we should add the
<code>ember-hash-helper-polyfill</code>, which makes the <code>hash</code> helper available in earlier
Ember versions, as a dependency of the addon:</p>

<p>```js
// package.json
{
  "name": "ember-cli-autocomplete",
  "version": "0.0.0",
  "dependencies": {</p>

<pre><code>(...)
"ember-hash-helper-polyfill": "0.1.0"
</code></pre>

<p>  },
}
```</p>

<h2>Wrapping up</h2>

<p>That wraps up my Complex Component Design in Ember.js series. Our component
improved by each post and I think we now have a pretty flexible and thus
reusable component. The main purpose of the series, however, is education, so I
hope that I was able to transfer some of the knowledge I've acquired by building
components.</p>

<p>If you would like to read the whole series as a pdf, just give my your email
address below and I'm sending it to you.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rock and Roll with Ember.js 2.5 is released]]></title>
    <link href="http://balinterdi.com/2016/05/03/rock-and-roll-with-ember-dot-js-2-dot-5-is-released.html"/>
    <updated>2016-05-03T10:22:00+02:00</updated>
    <id>http://balinterdi.com/2016/05/03/rock-and-roll-with-ember-dot-js-2-dot-5-is-released</id>
    <content type="html"><![CDATA[<p>I published a new version of <a href="http://rockandrollwithemberjs.com">the Rock and Roll Ember.js book</a>, and the
related application. It now runs on Ember, Ember Data and Ember CLI ~2.5.0.</p>

<p>More importantly, I made other improvements that serve to improve clarity and
reduce the number of new things the reader has to absorb at each step, which I
think is hugely important for an efficient, non-frustrating learning process.</p>

<ol>
<li><p>The biggest change (and simplification) is that I no longer sort the songs
from the get-go. To do so, I needed to use the <code>SortableMixin</code> and later, when
that was gone, an <code>ArrayProxy</code>. This resulted in other simplifications, like
not having to use (and maintain) a jsbin for that code snippet that used the
"global" Ember application building style and iterated on the magical
<code>sortedContent</code> property.</p></li>
<li><p>I also improved the flow of the Components chapter, rearranged some sections,
explained a few things that help comprehension and moved a few things that
only add to the learning burden.</p></li>
<li><p>I created an Appendix, called "Encore" to further the rock analogy. I felt
(and got matching feedback) that on some occasions there were too many
"sidebar" explanations (called "Backstage" sections in the book), that either
weren't important enough to warrant holding up the flow of explanation or
lacked context. I moved these sections into the Encore where interested
readers can learn about these topics when they see fit.</p></li>
<li><p>Last, but not least, I went through the book and built the application from
scratch to see that everything still works. I also applied git tags at the
end of each chapter so that readers of <a href="http://rockandrollwithemberjs.com/#light-my-fire">the middle-</a> and <a href="http://rockandrollwithemberjs.com/#stairway-to-heaven">high-tier packages</a>
can skip to each chapter in the code in a very simple way, using <code>git checkout</code>.</p></li>
</ol>


<p>(There were some other changes, the whole list of which you can see <a href="https://github.com/balinterdi/rarwe-issues/issues?q=is%3Aissue+milestone%3A2.5">here.</a>)</p>

<p>This is the most significant update since I published the Ember 2 version of the
book last October and I believe following the book (and the building of the app)
became even easier.</p>

<p>If this piqued your interest, you can download a sample chapter below.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Complex Component Design in Ember - Part 3 - Replace the observer]]></title>
    <link href="http://balinterdi.com/2016/04/08/complex-component-design-in-ember-replace-the-observer.html"/>
    <updated>2016-04-08T09:54:00+02:00</updated>
    <id>http://balinterdi.com/2016/04/08/complex-component-design-in-ember-replace-the-observer</id>
    <content type="html"><![CDATA[<p><em>This is part 3 of my Complex Component Design series. Here are the preceding posts:</em></p>

<ul>
<li><a href="/2015/09/10/complex-component-design-in-ember-intro.html"><strong>Intro</strong></a></li>
<li><a href="/2015/12/18/complex-components-in-ember-dot-js-part-1-analyzing-user-flows.html"><strong>Part 1 - Analyzing User Flows</strong></a></li>
<li><a href="/2016/02/04/complex-components-in-ember-dot-js-part-2-towards-a-more-reactive-component.html"><strong>Part 2 - Towards a more reactive component</strong></a></li>
<li><strong>Part 3 - Replace the observer</strong></li>
<li><a href="/2016-05-26-complex-component-design-in-ember-part-4-use-the-hash-helper.html"><strong>Part 4 - Use the hash helper</strong></a></li>
</ul>


<p>You can find the code for this post <a href="https://github.com/balinterdi/ember-cli-autocomplete/releases/tag/ccd-part-three">on Github.</a></p>

<hr />

<p>In the last post, we refactored towards a more reactive component and got
pretty far. However, we established that we'd still have to remove the observer
that was also causing a weird bug:</p>

<p><img src="/images/posts/complex-component-design-ember/jpj-too-good-bug.gif" alt="JPJ is too good to be replaced" /></p>

<h3>Event origin and data owner components are different</h3>

<p>The reason we introduced an observer was that we wanted to trigger an action
when one of the options was selected via cycling through them and hitting the
return key on the focused option. Since the necessary data for that event was
contained in the <code>auto-complete-option</code> component but the source of the keyboard
event was the <code>auto-complete</code> component, we couldn't simply trigger the action
with the right data from the event source.</p>

<p>We fixed this by using an observer so that even though the event that
should trigger the action was fired "upstream", in the <code>auto-complete</code>
component, we could react to this change "downstream", in the appropriate
<code>auto-complete-option</code> whose <code>isSelected</code> property became true:</p>

<p>```js
// addon/components/auto-complete-option.js
import Ember from 'ember';</p>

<p>export default Ember.Component.extend({
  (...)</p>

<p>  didBecomeSelected: Ember.observer('isSelected', function() {</p>

<pre><code>let isSelected = this.get('isSelected');
if (isSelected) {
  this._selectItem();
}
</code></pre>

<p>  }),</p>

<p>   _selectItem() {</p>

<pre><code>let item = this.get('item');
this.get('on-click')(item, this.get('label'));
</code></pre>

<p>  }
});
```</p>

<p>Our analysis of the cause already hints at the solution. We could move the
knowledge of which option is selected up to the <code>auto-complete</code> component and
then, when the user hits the return key to select the focused option, trigger
the action with the data that we have at our disposal.</p>

<h3>Centralized power in auto-complete</h3>

<h4>Changes in components</h4>

<p>We will maintain the selected option in <code>auto-complete</code> and trigger the
<code>selectItem</code> action when one of them is selected via a return key event (I
skipped the code snippet that calls <code>selectOption</code> for return):</p>

<p>```js
// addon/components/auto-complete.js
import Ember from 'ember';</p>

<p>export default Ember.Component.extend({
  (...)
  selectOption: function(event) {</p>

<pre><code>event.preventDefault();
const focusedIndex = this.get('focusedIndex');
if (Ember.isPresent(focusedIndex)) {
  this.set('selectedIndex', focusedIndex);
  this.send('selectOption', this.get('selectedOption'));
}
this.set('isDropdownOpen', false);
</code></pre>

<p>  },</p>

<p>  selectedOption: Ember.computed('selectedIndex', 'options.[]', function() {</p>

<pre><code>return this.get('options').objectAt(this.get('selectedIndex'));
</code></pre>

<p>  }),
});
```</p>

<p>On line 11, we call the <code>selectOption</code> action (renamed from <code>selectItem</code>) with
the (new) selected option. <code>selectedOption</code> is simply the option that has the
<code>selectedIndex</code>.</p>

<p>Independently of the current <code>selectOption</code> refactor, let's fix a nasty
bug by making sure to reset the <code>focusedIndex</code> when the input changes:</p>

<p>```js
// addon/components/auto-complete.js
import Ember from 'ember';</p>

<p>export default Ember.Component.extend({
  (...)
  actions: {</p>

<pre><code>inputDidChange(value) {
  this.get('on-input')(value);
  this.set('focusedIndex', null);
  (...)
}
</code></pre>

<p>  }
});
```</p>

<p>Next, let's look at how the <code>selectOption</code> action needs to change:</p>

<p>```js
// addon/components/auto-complete.js
import Ember from 'ember';</p>

<p>export default Ember.Component.extend({
  (...)
  _displayForOption(option) {</p>

<pre><code>const displayProperty = this.get('displayProperty');
return option.get(displayProperty);
</code></pre>

<p>  },</p>

<p>  actions: {</p>

<pre><code>selectOption(option) {
  let inputValue = this._displayForOption(option);
  this.get('on-select')(option);
  this.set('isDropdownOpen', false);
  this.set('inputValue', inputValue);
},
(...)
</code></pre>

<p>  }
});
```</p>

<p>One of the things that has changed is that it now only receives one argument,
<code>option</code> as the label of the option can now be computed internally, from within
the component.</p>

<p>That means that the label now does not need to be passed to the
<code>auto-complete-option</code> components and that its action that gets triggered when
the user clicks on it needs to be adjusted:</p>

<p>```js
// addon/components/auto-complete-option.js
import Ember from 'ember';</p>

<p>export default Ember.Component.extend({
  tagName: 'li',
  classNames: 'ember-autocomplete-option',
  classNameBindings: Ember.String.w('isSelected:active isFocused:focused'),</p>

<p>  item: null,
  'on-click': null,
  isFocused: false,
  isSelected: false,</p>

<p>  click() {</p>

<pre><code>this.get('on-click')(this.get('item'));
</code></pre>

<p>  }
});
```</p>

<p>You can see I removed the observer and that I only send the item (not the label,
see the very first code example) in the action handler to comply with the new
API of the <code>selectOption</code> action.</p>

<h4>Changes in templates</h4>

<p>Let's see how the templates need to change to accommodate that change.</p>

<p>First of all, the template of the <code>auto-complete</code> component needs to yield the
<code>options</code> to be consumed downstream. Let's also not forget to rename
<code>selectItem</code> to <code>selectOption</code>:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;!-- addon/templates/components/auto-complete.hbs --&gt;


&lt;p&gt;{{yield isDropdownOpen&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    inputValue
    options
    focusedIndex
    selectedIndex
    (action &quot;toggleDropdown&quot;)
    (action &quot;selectOption&quot;)
    (action &quot;inputDidChange&quot;)}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<p>Then, the <code>each</code> loop should iterate through <code>options</code>, and not through
<code>matchingArtists</code> as before:</p>

<p><div>
  <pre><code class='html'>&lt;/p&gt;

&lt;!-- tests/dummy/app/templates/index.hbs --&gt;


&lt;p&gt;{{#auto-complete&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  on-select=(action &quot;selectArtist&quot;)
  on-input=(action &quot;filterArtists&quot;)
  options=matchingArtists
  displayProperty=&quot;name&quot;
  class=&quot;autocomplete-container&quot; as |isDropdownOpen inputValue options
                                     focusedIndex selectedIndex
                                     toggleDropdown onSelect onInput|}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  &lt;div class=&quot;input-group&quot;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{auto-complete-input
    value=inputValue
    on-change=onInput
    type=&quot;text&quot;
    class=&quot;combobox input-large form-control&quot;
    placeholder=&quot;Select an artist&quot;}}
{{#auto-complete-list
    isVisible=isDropdownOpen
    class=&quot;typeahead typeahead-long dropdown-menu&quot;}}
  {{#each options as |option index|}}
    {{#auto-complete-option
        item=option
        on-click=onSelect
        isFocused=(eq focusedIndex index)
        isSelected=(eq selectedIndex index)}}
      &amp;lt;a href=&quot;#&quot;&amp;gt;{{option.name}}&amp;lt;/a&amp;gt;
    {{/auto-complete-option}}
  {{else}}
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;No results.&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  {{/each}}
{{/auto-complete-list}}
{{#auto-complete-dropdown-toggle on-click=toggleDropdown class=&quot;input-group-addon dropdown-toggle&quot;}}
  &amp;lt;span class=&quot;caret&quot;&amp;gt;&amp;lt;/span&amp;gt;
{{/auto-complete-dropdown-toggle}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  &lt;/div&gt;
{{/auto-complete}}</code></pre>
</div>
</p>

<p>The bug at the beginning of the post is now gone:</p>

<p><img src="/images/posts/complex-component-design-ember/jpj-too-good-to-go-fixed.gif" alt="JPG too-good-to-go bug fixed" /></p>

<h3>In the next episode...</h3>

<p>We now have a working, state-of-the-art component design with no coupling
between the sub-components and no observers. One thing that is not ideal,
though, is the number of parameters the <code>auto-complete</code> components yields (see
last code snippet).</p>

<p>Just as you wouldn't have a method with 7 or 8 positional parameters, you don't
want a component that yields that many properties matched by position. So in the
next installment of this series, we'll use the <code>hash</code> helper to transform that
long list into keyed parameters.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rock and Roll with Ember.js - Now on 2.4 and with code diffs]]></title>
    <link href="http://balinterdi.com/2016/03/24/rock-and-roll-with-ember-dot-js-now-on-2-dot-4-and-with-code-diffs.html"/>
    <updated>2016-03-24T15:12:00+01:00</updated>
    <id>http://balinterdi.com/2016/03/24/rock-and-roll-with-ember-dot-js-now-on-2-dot-4-and-with-code-diffs</id>
    <content type="html"><![CDATA[<p>I have just sent an updated version of Rock and Roll with Ember.js to my
readers. <a href="http://rockandrollwithemberjs.com">The app</a> now runs on Ember 2.4.3.</p>

<p>The biggest change in this release is that I now leverage code diffs in code
snippets, where this makes understanding changes easier. It looks like this in
the pdf version:</p>

<p><img src="/images/posts/rarwe-2-4-released/code-diff-example.png" alt="Colored code diffs" /></p>

<p>Since the last release was more than two months ago and I constantly improve
things, there is a whole slew of other changes that you can see <a href="https://github.com/balinterdi/rarwe-issues/issues?q=is%3Aissue+milestone%3A2.4+is%3Aclosed">here</a>.</p>

<p>If you are not yet a reader yet and want to have an always up-to-date Ember
guide book, sign up below to get a sample chapter:</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rock and Roll with Ember.js demo - A public Ember.js example project]]></title>
    <link href="http://balinterdi.com/2016/02/26/rock-and-roll-with-ember-dot-js-demo-a-public-ember-dot-js-example-project.html"/>
    <updated>2016-02-26T11:04:00+01:00</updated>
    <id>http://balinterdi.com/2016/02/26/rock-and-roll-with-ember-dot-js-demo-a-public-ember-dot-js-example-project</id>
    <content type="html"><![CDATA[<p>I have a book called Rock and Roll with Ember.js that has an accompanying
application we develop throughout the book. I also maintain a demo version of
the same app which has been open-source since its inception. However, that demo app
has not received updates for a while now so I decided to do something about
this and spent some time this week on making it a state-of-the-art Ember 2 application.</p>

<p>Here are the main developments I have made:</p>

<ul>
<li><strong>Upgraded it to use the latest Ember, Ember Data and Ember CLI versions, 2.3.0.</strong></li>
<li><strong>Used <a href="http://www.ember-cli-mirage.com/">ember-cli-mirage</a> to seed the app with data and handle "backend" requests.</strong>
(Look, ma', no backend!)
<a href="http://www.ember-cli-mirage.com/">ember-cli-mirage</a> is fantastic addon that lets you set up route handlers,
fixtures, factories and many more to manage your seed data and mock your server
responses, both in development and tests. This was the first time I seriously
used it and I have grown to like it a ton! The author, <a href="https://twitter.com/samselikoff">Sam Selikoff</a>, helped
out tremendously and had an amazing turnaround on a few questions/issues.
I used the latest beta version, 0.2.0-beta.7, which you should definitely
check out and give feedback to Sam.</li>
<li><strong>Made it a modern, idiomatic Ember app.</strong>
It's not just Ember, but also Javascript that evolves at a neck-breaking space
(although to a lesser extent). I used the not-at-all elementary
<a href="https://github.com/abuiles/ember-watson">ember-watson</a> to modernize the Ember app and applied a few manual tweaks
for some of the Javascript parts, like using destructuring and <code>let</code> and <code>const</code>
instead of <code>var</code>.</li>
<li><strong>Deployed it to be publicly accessible.</strong>
Leveraging the most excellent <a href="https://www.pagefronthq.com/">PageFront</a>, the app is now deployed to their
platform. You can see it in action at <a href="https://rarwe-demo.pagefrontapp.com/">https://rarwe-demo.pagefrontapp.com</a>.
This was not even a task, I only needed to issue two commands, one to install
the add-on and one to deploy it.</li>
</ul>


<p>The source lives on Github, at <a href="https://github.com/balinterdi/rarwe-demo">balinterdi/rarwe-demo</a>.</p>

<p>As Mirage can also be used in production (although it's probably not common to
do that), you can check out <a href="https://rarwe-demo.pagefrontapp.com/">the "production" app</a>, with the same seed data I
used in development, and play around with it.</p>

<p>As I mentioned in the introduction, the full version of the app is developed
chapter by chapter in <a href="http://rockandrollwithemberjs.com">the Rock and Roll with Ember book</a>. You can download a
sample chapter below:</p>
]]></content>
  </entry>
  
</feed>
